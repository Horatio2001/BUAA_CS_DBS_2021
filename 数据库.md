##  数据管理技术的发展

数据的独立性是数据库系统的最基本的特征之一 。数据独立性是指应用程序数据结构之间相互独立, 互不影响。在三层模式体系结构中数据独立性是指数据库系统在某一层次模式上的改变不会使它的上一层模式也发生改变的能力。正是三级模式间的两层映像保证了数据库系统中的数据具有较高的数据独立性。数据独立性包括数据逻辑独立性和数据物理独立性。 

DBMS负责数据的物理结构和逻辑结构，应用程序只关注如何使用。

描述数据本身时还要描述数据之间的联系，使整个组织数据结构化。数据结构化是数据库主要特征之一，是数据库与文件系统的根本区别，

### 数据库系统管理特点：

1.数据冗余度小，易扩容

2.数据库系统具有较高的数据和程序独立性

​	`数据`的物理独立性是指数据的存储结构改变时，数据的逻辑结构可以不变，不影响应用程序。

​	`数据`的逻辑独立性是指数据的逻辑结构改变时，应用程序可以不变。

​		数据库系统提供了两方面的`映像（转换）`功能：

​			数据的存储结构与逻辑结构之间的映像：实现数据的物理独立性。（内模式）

​			数据的全局逻辑结构与某类应用所设计的局部逻辑结构之间的映像：实现数据的逻辑独立性。（外模式）

3.统一的数据控制功能

​	- 数据的==安全性==控制

​		保护数据防止不合法的使用造成数据的泄密和破坏。

​	- 数据的==完整性==控制

​		指数据的正确性有效性与相容性一致性。

​	- 并发控制

​		对多用户的并发操作进行控制、协调，保护数据的完整性。（事务处理技术）	

​	- 数据库恢复

​		将数据库从错误状态恢复到某一已知的正确状态。

4.数据的最小存取单位是数据项

​	- 既可以存取一个或一组记录，也可以数据库中某个或一组数据项。

### 模型

分为两个层次：1.概念模型（信息模型） 2.数据模型（层次、网状、关系模型）

概念模型最常用的表示方法：实体-联系方法（E-R）法

### 概念模型的基本概念

实体（Entity）：客观存在的可以区分的事物

属性（Attribute）：实体所具有的某一特性；

码（Key）：唯一标识实体的属性集；

域（domain）：某个（些）树形的取值范围；

实体性（Entity Type）：表示一类实体，用实体名及其属性姓名集合来抽象刻画。

联系（Relation）：实体型之间的联系，是实体之间的相互关联。

​	-名称

​	-类型 ： 一对一联系 一对多联系 多对多联系

​	-可以具有属性

## 概念模型

联系具有名称、类型，可以具有属性。

如`学生`和`课程`之间的联系属性为多对多，名称为`选修`，选秀的一个属性为`成绩`

e-r图的组成：实体、联系、属性

​	-实体：长方形

​	-属性：椭圆形，无向边变把实体与其属性连接起来。

​	-联系；菱形，无向边联系菱形及其有关实体相连，再无向边旁标上联系的类型，若联系有属性则同上。

同一个实体内补各实体之间也可以存在联系，多实体之间可以存在联系，两实体之间可以存在多种联系。

### E-R图语义扩充

1.存在依赖：E，如子女实体存在依赖于职工实体，则其为弱实体。

2.标识依赖：实体不能由自己的属性来唯一标识，二必须通过与他相联系的另一实体一起来标识，那么称该实体标识依赖于另一个实体。

3.实体的子类：子类可以继承父类的属性 子嘞也可以附加某些属性 子类之间的交不一定为空

### 概念模型实例（E-R）

根据需求描述确定实体、关系、属性。

## 数据模型

数据模型是严格定义的概念集合，这些概念精确的描述系统中数据的静态特性、动态特性和完整性约束。

数据模型的三要素：`数据结构` `数据操作` `完整性约束`

### 数据结构

数据结构由描述数据对戏那个以及对象之间联系的一组概念组成 包括：

​	-描述对象的类型、内容、性质的概念，入关系中的域、属性等

​	-描述对象之间联系的概念，如关系模型中的关系

是数据静态特性的描述

数据结构是刻画数据模型最重要的方面，通常根据数据结构的类型来命名数据模型（关系数据模型的数据结构就是关系）

### 数据操作

定义操作的确切含义、操作符号、操作规则及操作语言；

是数据动态特性的描述

数据库主要有检索和更新（插入、删除、更改）

### 约束条件

是完整性规则的集合，完整性规则是给定的数据模型中，数据及其联系所有的制约和依存规则，用以保证数据的正确、相容

完整约束条件包括：

​	-符合这种税局模型所必须遵守的基本的通用的完整性约束条件。

​	-针对具体数据的特定语义的约束条件。

## 数据模型的分类

层次模型、网状模型、关系模型

### 层次模型

树状图，有向树，结点代表实体型，连线表示两实体型间的一对多联系

​		特征：有且仅有一个结点没有双亲，其他结点有且仅有一个双亲

​		缺点：无法表示多对多关系

### 网状模型

图结构，有向图，结点代表实体型，连线标识两实体型间的一对多联系

​		特征：表达联系种类丰富，结构复杂

### 关系模型

```二维表```，用二维表格结构来表示实体及其实体之间的联系

## 数据库系统结构

具有三级模式两级映像

### 模式

也称为逻辑模式和概念模式，是数据库中全体数据的逻辑结构和特性的描述，是所有用户的公众数据视图。

是三级模式的核心，不涉及存储细节和编程

具体定义数据的逻辑结构、数据安全性、完整性要求

数据库系统提供模式描述语言（模式DDL）

### 外模式

也称为子模式或用户模式，即与某一应用有关的数据的逻辑表示

通常是模式的子集，不同应用的外模式可以相互覆盖，一个应用只能启用一个外模式

数据库系统提供外模式描述语言（外模式DDL）

### 内模式

物理模式、存储模式，对于数据的物理结构和存储方式的描述

数据库系统提供外模式描述语言（外模式DDL）

### 三级模式的结构优点

保证数据独立性

​	-模式与内模式分开 数据物理独立性

​	-外模式与模式分开 数据逻辑独立性

简化用户接口 方便用户使用

​	-用户只按照外模式操作 无需了解数据库的总体逻辑结构与物理存储结构

有利于数据共享

​	-从模式产生不同的外模式 外模式间可相互覆盖

有利于数据的安全保密

​	-应用程序只能操作其对应的外模式

## DBMS

### 主要功能

数据存取功能

​	-提供DML语言 对数据库进行检索 插入 修改 删除

数据库运行管理

​	-并发控制、存取控制、完整性约束条件检查和执行、日志组织和管理、事务管理和自动恢复

数据组织、存储和管理

​	-用户数据、缩影、数据字典的组织、存储和管理，包括文件结构、存取方式、数据之间联系的实现等

数据库建立和维护

​	-数据的装入、转换，数据库的转储、恢复、性能件事和分析

### 组成

DDL DML DCL

语言编译处理程序

系统运行控制程序

​	-包括系统总控、存取控制、并发控制、完整性控制、保密性控制、数据存取和更新、通信控制等程序。

系统建立和维护程序

​	-数据装入、数据库系统恢复、性能监督、工作日志等程序。

数据字典

​	-也称为数据目录或系统目录，由一系列表组成，存储着数据库中有关信息的当前描述，包括数据库的三级模式、用户名表、用户权限等信息。

​	**“元数据：描述数据的数据”**

## DBA

建库方面

​	-确定模式、外模式、存储结构、存取策略、负责数据的整理和装入

用库方面

​	-定义完整性约束条件，规定数据的保密级别、用户权限，监督和控制数据库的运行情况，制定后院和恢复策略，负责故障恢复

改进

​	-监督分析系统的性能（空间利用率，处理效率）

​	-数据库冲组织，物理上重组织，以提高性能

​	-数据库冲构造，设计上较大改动，模式和内模式修改



# 2.关系数据库

## 关系数据库

### 数学定义

元组：n个域参与的笛卡尔积成为n元组，元组中的每一个值叫做一个分量。

### 关系的定义

笛卡尔积的子集叫做在域D1...Dn上的关系，用R(D_1,D_2,...,D_n)表示，R是关系的名字，n是度或者目

### 关系可以表示为二维表

​	-表的框架由域构成

​	-表的每一行为元组 每一列为域

​	-每个列附加一个名称，称为`属性`	属性的名字是唯一的

### 关系的性质

​	-列是同质的，来自同一个域

​	-不同的列可出自同一个域 但不能有相同的属性名

​	-列的顺序无所谓

​	-任意两个元组不能完全相同

​	-行的顺序无所谓

​	-每一分量必须是不可再分的数据 满足这一条件的关系称作满足`第一范式（1NF）`的

 ## 关系模型的数据结构

关系模型的数据结构：关系

### 几个基本概念

#### 码(Key)

​	-候选码：关系中的某一属性组，若他得知唯一的表示了一个元组，并具有最小性(如果去掉某个属性仍能唯一标识 就不满足最小性)，则称该属性组为候选码

​	-主码：若一个关系有多个候选码，则选定其中一个为主码

​	-候选码中的主属性称为主属性，不包含在任何候选码中的属性称为非主属性。

#### 关系模式

​	关系的描述，`R(U,D,dom,F,I)`，其中`U`为组成该关系的属性名集合 `D`为属性集U的域 `dom`为属性向域的映像集合 `F`为属性间的依赖关系集合 `I`为完整性约束集合·

​	关系模式通常可以记作R(A~1~,A~2~,...,A~n~)，R为关系名，A~1~...A~n~为属性名，D和dom直接说明为属性的类型、长度。

​	关系是关系模式在某一时刻的状态或内容。关系模式相对稳定的，而关系是动态的，是随时间不断变化的

#### 关系数据库

​	关系模式的集合构成关系数据库模式-关系数据库的型

​	关系的集合则构成具体的关系数据库-关系数据库的值

## 关系模型的语义约束

实体完整性和参照完整性是关系模型必须支持的约束条件。

### 实体完整性

​	– 要有属性或属性组合作为主码，主码值不可为空或部分为空。或定义为若属性A是关系R的主属性，则属性A不能取空值。

​	– 空值的含义是：不知道或不存在的值。

### 参照完整性

#### 外部码

​	设F是`基本关系R`的一个或一组属性，但不是R的码，如果F与基本关系S的主码Ks相对应，则称F是关系R的`外部码`，并称R为`参照关系`，S为`被参照关系`或`目标关系`。R和S不一定不同。

​	目标关系S的主码Ks和参照关系的外部码F必须定义在一个域上。

#### 参照完整性

​	如果关系R的外部码F~k~与关系S的主码P~k~相对应，则R中的每一个元祖的F~k~值或者等于S中某个元组的P~k~值，或者为空。

## 关系模型的数据操作

​	-特点是集合操作，一次一集合方式。

​	-关系数据操作的基础是关系运算，主要有两种：代数方式，逻辑方式。

### 关系代数简介

常规集合运算：并、差、交、广义笛卡尔积（乘）

特有关系运算：选择、投影、连接、自然连接、求商

### 关系演算简介

${\{t|\Phi(t)\}}$t为元组变量${\Phi(t)}$是元祖关系演算公式。

域关系演算表达式的形式

${\{(x_1,x_2,...,x_k)|\Phi(x_1,x_2,...,x_k)\}}$

其中x~i~代表域变量，$\Phi$为域关系演算公式。

## 关系代数

### 广义笛卡尔积

​	关系R、S度为n，m，笛卡尔积为元组集合，前n个分量是R中的一个元组，后m个分量是S中的一个元组，R*S的度为（n+m），

### 选取或限制

​	在关系R中选择满足给定条件的元组。记作：

​	${\sigma_F(R)=\{t|t\in R,F(t)='真'\}}$

​	如F：S#=1923

### 投影

​	从关系R（U）取若干属性列并删除重复行组成新的关系

​	${\Pi_A(R)=\{t[A]|t\in R,A\subseteq U\}}$

​	如A：S#

### 连接

​	关系R和S在属性X和Y上的连接（X、是连接属性，即X、Y包含同等数量的属性，且相应的属性均具有共同的域），是从两个关系的广义笛卡儿积R中选取给定属性(X和Y)间满足$\theta$比较条件的元组。

​	${R \Join S=\{t|t=<r,s> \land r \in R\land s\in S \land r[X]\theta s[Y]\}}$

​	$\theta$为比较条件，

​	$\theta$为=时，成为等值连接

​	$\theta$为<时，为小于连接

​	$\theta$为>时，为大于连接

当前表中没有必要的属性时，就需要与其他表进行连接。

### 自然连接

​	在等值连接的情况下，连接属性X和Y是相同属性时候。

​	需要在等值连接结果基础上在进行投影运算，去掉重复的属性列。

### 除法

​	R（X，Y）与关系S（Z），其中Y和Z具有相同的属性数，且对应属性出自相同域，关系R除以关系S所得的商关系是关系R在属性X上投影的一个子集，该自己和S（Z）的笛卡尔积必须包含R（X，Y）中。

​	${R\div S=\{t|t \in \Pi_x(R)\land s\in S\land <t,s>\in R\}}$

## 元组关系演算与域关系演算

元组为变量则为元组关系演算

域为变量则为域关系演算

### 元组关系演算公式的递归定义

#### 原子公式

原子公式有三类：

​	-R（t）元组

​	-t[i]$\theta$u[j] 分量的比较关系

​	-t[i]$\theta$c or c$\theta$t[i] 与常数的比较关系

#### 优先次序

算数比较符最高

量词次之，存在高于任意

逻辑运算符最低，非高于且，且高于或

### 元组演算与关系代数的等价性

关系演算可以表达五种基本关系运算。

### 域演算公式的递归定义

域公式有三类：

​	-R（x1,x2...）元组

​	-xi$\theta$xj 分量的比较关系

​	-xi$\theta$c or c$\theta$xi 与常数的比较关系		

### 关系运算的安全约束

​	把不产生无限关系和无穷验证的运算称为安全运算，其运算表达式称为安全表达式，对其所采取的限制称为安全约束。

​	关系代数一定是安全运算，关系演算不一定是，所以对关系演算要进行安全约束。

​	通常采用的安全约束方法是对$\Phi$定义一个有限的符号集DOM（$\Phi$），使$\Phi$的运算结果及其中间结果所产生的关系及其元组的各个分量都必须属于DOM（$\Phi$）。

## 关系数据语言概述

### 数据库数据语言

​	-数据描述语言DDL

​		包括模式DDL，外模式DDL，内模式DDL

​	-数据操纵语句DML

​		增删改查

​	-数据控制语言DCL

​		负责完成数据库的安全性控制、完整性控制、并发控制等。

### 关系数据语言特点

​	-一体化

​		将数据的定义、查询、更新、控制等功能融为一体，只给用户提供一种称之为查询语言的语言，便于用户学习。

​	-非过程化

​		用户只需提出干什么，怎么解决由DBMS负责

​	-面向集合的存取方式

​		操作对象是一个或多个关系，操作的结果也是一个新关系

即可

​	-既可以独立使用 又可以嵌套

### 关系数据语言的分类

​	关系数据语言的核心是查询，所以又称为查询语句，而查询往往表示成一个关系运算表达式，因此关系运算时基础关系运算的分类也决定了关系语言的分类。

# 3.关系数据库标准语言SQL

## SQL特点

​	-综合统一

​	-高度非过程话

​	-面向集合的操作方式

​	-以同一种语法结构提供两种使用方式

​	-语言简洁，易学易懂

| SQL功能 | 操作符               |
| ------- | -------------------- |
| 查询    | Select               |
| 定义    | Create,drop,alter    |
| 操纵    | insert update delete |
| 控制    | Grant revoke         |

## SQL语言的基本概念

### 基本表与导出表

​	- 基本表：实际存在的表，每个表再存储中可用一个存储文件来表示

​	- 导出表：从基本表导出的表，有视图(view)和快照(snapshot)。

​		-视图是一个虚表，即视图所对应的数据不实际存储在数据库中，只在数据库的数据字典中存储视图的定义。

​		-视图一经定义就可以和基本表一样进行查询等操纵，也可以用来定义新的视图

## SQL数据查询功能

查询的基本结构是select-from-where组成的查询块

​	SELECT 目标列

​	FROM 基本表（或视图）

​	WHERE 检索条件

### 投影检索

采用DISTINCT消去结果中的重复行

```sql
SELECT DISTINCT C#

FROM SC;
```

### 选取检索

由WHERE字句指出查询条件

检索条件包括比较运算符、布尔运算符（AND OR NOT）、（）

```sql
# 检索成绩在70到85之间的学号课号和成绩
	SELECT S#, C#, G
	FROM SC
	WHERE G BETWEEN 70 AND 85
```

### 排序检索

​	在SELECT-FROM-WHERE查询块后接OERDER BY子句

​	格式：ORDER BY 列名 ASC（升序） 或 DESC（降序）

​	default为升序

​	可以是单列或多列排序

​	该子句在SELECT语句中作为最后一个子句出现

```sql
# 检索全体学生信息，并按系号升序，同一个系按年龄降序排列
	SELECT *
	FROM S
	ORDER BY SD, SA DESC
```

### 连表检索

把相互关联的表连接起来，实现多表数据检索。

```sql
SELECT #指明选取的列名 来自多个表
FROM  #指明要链接的表名
WHERE #指明连接条件与选取条件
```

连接条件一般如下：

$ [<表名>.]<列名><比较运算符>[<表名>.]<列名>$

```sql
# 检索学生张华所学课程的成绩
	SELECT SN, C#, G
	FROM S, SC
	WHERE S.S#=SC.S# AND SN=‘张华’
```

#### 表自身的连接

还可以通过定义别名，将一个表看成两个表，进行连接

```sql
# 检索所有比李永年龄大的学生姓名 年龄
	SELECT X.SN, X.SA
	FROM S X, S Y
	WHERE X.SA>Y.SA AND Y.SN = ‘李永’
```

#### 外连接

​	在连接谓词某一边家（\*或\+），则逻辑上为\*所在变的表增加了一个空行。它可以与另一个表中所有不满足连接条件的元组进行连接，使这些元组能够输出。

```sql
# 检索所有学生的全部信息
	SELECT *
	FROM S, SC
	WHERE S.S#=SC.S#(*);
```

### 子查询嵌套检索

​	where子句可以包含另一个查询块，该查询块称为`子查询`或者`嵌套查询`，包含子查询的语句称为`外部查询`。

​	外部查询利用子查询来获取检索条件的条件值，检索条件根据自查询的结果来确定外部查询的结果数据

​	子查询按照与外部查询的联系不同，分为普通子查询和相关自查询

​		-普通子查询：与外部查询无关，可单独执行得一组值

​		-相关子查询：把外查询的列值作为检索条件的条件值

```sql
SELECT
FROM A
WHERE(SELECTED FROM B WHERE B.X < A.Y)
```

#### 涉及同一个表的子查询

```sql
# 检索与李永同岁的学生姓名
	SELECT SN
	FROM S
	WHERE S.SA = 
			(SELECT SA FROM S 
				WHERE SN = ‘李永’);
```

​	子查询返回单值，可以直接用比较运算符查询，如果返回一组值，则必须在比较运算符和子查询之间插入ANY、ALL等操作符。

```sql
# 检索选修C2课程的学生姓名
	SELECT SN
	FROM S
	WHERE S#=ANY
		(SELECT S# FROM SC
			WHERE C#='C2');
```

```sql
# 检索选修C2课程的成绩最高的学生学学号
	SELECT S#
	FROM SC
	WHERE C#='C2'AND
		G>ALL
			(SELECT G FROM SC
				WHERE C#='C2');
```

#### 用IN检索

​	in可代替“=ANY”，是集合运算中的"$\in$"运算。

```sql
# 检索选秀C2课程的学生姓名
	SELECT SN
	FROM S
	WHERE S# IN 
		(SELECT S# FROM SC
			WHERE C#='C2');
```

#### 用NOT IN检索

​	NOT IN表示不再集合中，与！=ALL相同。

#### 用EXISTS检索

​	$\exists$,当且仅当子查询结果非空时为真。

```sql
# 检索选修C2课程的学生姓名
	SELECT SN
	FROM S
	WHERE EXISTS
		(SELECT * FROM SC
		WHERE S#=S.S# AND C#='C2')
```

#### 用NOT EXISTS检索

​	表示不存在，在子查询结果为空时为真。

##### 用NOT EXISTS表达全称量词$\forall$

​	$(\forall x)P = \neg (\exists x (\neg P))$即用NOT eXISTS表达全称量词

```sql
# 检索选秀所有课程的学生姓名
	SELECT SN
	FROM S
	WHERE NOT EXISTS
		(SELECT * FROM C
		WHERE NOT EXISTS
			(SELECT * FROM SC
			WHERE S#=S.S# AND C#=C.C#))
# 即查找不存在他没选修的课程的学生
```

##### 用NOT EXISTS表达蕴含

$(\forall y)p \rightarrow q = \neg \exists y(p \and \neg q) $ 

```sql
# 检索至少选修了学生S2选修的全部课程的学生学号
	SELECT DISTINCT S#
	FROM SC SCX
	WHERE NOT EXISTS
		(SELECT * FROM SC SCY
		WHERE SCY.S#='S2' AND NOT EXISTS
			(SELECT * FROM SC SCZ
			WHERE S#=SCX.S# AND C#=SCY.C#))
```

### 并、差、交检索

UNION MINUS INTERSECT

```sql
# 检索选修了C1或C2课程的学生学号
	SELECT S# 
	FROM SC
	WHERE C#=C1'
	UNION
	SELECT S# 
	FROM SC
	WHERE C#='C2'
```

```sql
# 检索无人选修的课程号和名称
	SELECT C#, CN FROM C WHERE C# IN
		(SELECT C# FROM C
		MINUS
		SELECT DISTINCT C# FROM SC)
```

### 库函数检索

COUNT()按列值计数，COUNT（*）对行计数

SUM()对数值列求和

AVG()求数值列平均值

MAX()在列中找最大值

MIN()在列中找最小值

只能在SELECT字句和HAVING字句中出现

```sql
# 检索学生总数
	SELECT COUNT(*) FROM S
```

```SQL
# 检索选秀了课程的学生人数
	SELECT COUNT(DISTINCT S#) FROM SC
```

```sql
# 求学号为S4的学生的总分和平均分
	SELECT SUM(G),AVG(G)
	FROM SC
	WHERE S#='S4'
```

```sql
# 检索选修了C1课程的学生最高分
	SELECT MAX(G) FROM SC WHERE C#='C1'
```

### 分组检索

按属性列将关系的元组分组，每组在这些分组属性列上具有相同值，对每一组执行SELECT操作

分组字句：

​	GROUP BY 列名

​	[HAVING 条件表达式] ——分组条件

```sql
# 检索至少选秀三门课程的学生学好和选课门数
	SELECT S#, COUNT(*)
	FROM SC
	GROUP BY S#
	HAVING COUNT(*) >=3
```

```sql
# 求选修四门以上课程的学生学好和总成绩（不统计不及格的课程）最后按降序列出总成绩排序名单
	SELECT S#, SUM(G)
	FROM SC
	WHERE G>=60
	GROUP BY S#
	HAVING COUNT(*)>=4
	ORDER BY SUM(G) DESC
```

### 算术表达式值的检索

```sql
# 有职工表EMP（EMP#，EMPN，JOB，SALARY，BONUS，DEPT）要求检索所有PROGRAMMER的奖金大于工资25%的职工姓名和一年的总收入，并按奖金与工资之比的降序排列
	SELECT EMPN, BOUNS/SALARY BS,
		12*(SALARY+BONUS) TOTAL
	FROM EMP
	WHERE JOB='PROGRAMMER'
		AND BONUS>0.25*SALARY
	ORDER BY BONUS/SALARY DESC
```

### 部分匹配查询

%：代表任意序列的0个或多个字符

_：代表任意单个字符

# 4.关系数据理论

## 数据依赖的概念

一个关系内部属性值之间相互依赖又相互制约的关系称为数据依赖。分为两种，函数依赖和多值依赖。

## 函数依赖

### 函数依赖的定义

设R(U是属性集U上的关系模式X、Y是U的子集。r是R的任意一个具体关系，t , s 是r中任意两个元组。如果t[X] = s[X]，则[Y] = s[Y]，则称“X函数确定Y”或“Y函数依赖于X”，记作：$X \rightarrow Y$

即X的每个具体值，Y有唯一的值与之对应。

#### 函数依赖相关术语

平凡与非平凡的函数依赖：若$Y \subseteq X $则为平凡依赖，一般是不平凡的。

对于$x \rightarrow y$把x称为决定因素

#### 函数依赖与属性间的联系类型

##### 一对一联系

如学生学号与身份证号

$X \rightarrow Y, Y \rightarrow X$

##### 一对多联系

如学生所在系的系名与学号

只存在$Y \rightarrow X$

##### 多对多联系

如学号与课程名

不存在函数依赖

### 三种函数依赖

#### 完全函数依赖与部分函数依赖

任意真子集都不能推出则是完全依赖。***箭头上面f是完全 p是部分 t是传递***

#### 传递函数依赖

在R(U)中，如果$X \rightarrow Y, Y \rightarrow Z$，且$Y \not \rightarrow X$，则称为Z对X传递依赖。

### 关系键的形式定义

K为属性或组合，若U对K完全依赖则K为候选码，不包含在任何码的属性称为非主属性

### 函数依赖公理系统

#### 函数依赖的逻辑蕴含

关系模式R<U,F>中，X，Y是属性，从F中的函数依赖能够推出$X \rightarrow Y$则称F逻辑蕴含$X \rightarrow Y$。

##### 函数依赖集F的闭包

为F所逻辑蕴含的函数依赖的全体称为F的闭包，记作$F^+$

#### Armstrong公理及推论

##### A1自反律

若$Y \subseteq X \subseteq U$，则$X \rightarrow Y$为F所蕴含

##### A2增广律

若$X \rightarrow Y$为F所蕴含，且$Z \subseteq U$则$XZ \rightarrow YZ$为F所蕴含

##### A3传递律

若$X \rightarrow Y， Y \rightarrow Z$为F所蕴含，则$X \rightarrow Z$为F所蕴含

##### 合并规则

若$X \rightarrow Y， Y \rightarrow Z$有$X \rightarrow YZ$ 

##### 伪传递规则

$X \rightarrow Y, WY \rightarrow Z$有$XW \rightarrow Z$

##### 分解规则

由$X \rightarrow Y, Z \subseteq Y$有$X \rightarrow Z$

##### 定理一

$X \rightarrow A_1 A_2 ... A_k等价于X \rightarrow A_i成立$

#### 属性集的闭包

$X \rightarrow Y, 等价于Y \subseteq X_F^+$

##### 闭包的计算

---

Input:X, F

OutPut:$X_F^+$

$X_F^+$:=X;

do

​	for any $A \subseteq X_F^+ $do

​		if在F中存在函数依赖$A \rightarrow B$

​			then $X_F^+$=$X_F^+ \or B$

While($X_F^+$发生变化且$X_F^+ \not = U$)

---

#####  Armstrong是有效的完备的

F出发推出来的函数依赖一定在F所蕴含的函数依赖全体中

F元含的函数依赖的全体中的每一个函数依赖，必定可以有F推出

#### 函数依赖集的最小依赖集

##### 函数依赖集等价

闭包相等则称为等价，同时相互覆盖。

##### 最小依赖集

F中任意函数依赖$X \rightarrow A$，A必是单属性（右部单属性化

F中不存在$X \rightarrow A$使得F与$F - \{ X\rightarrow A\}$等价（没有多余的FD

F中不存在$X \rightarrow A$，在X中有真子集Z使得F与$F-\{X \rightarrow A\}\or\{Z\rightarrow A\}$等价（FD左部没有多余属性（把XA换成ZA

##### 极小化处理

每个函数依赖集F均等价于一个极小函数依赖集Fm，Fm为F的最小依赖集

##### 极小化算法

$X \rightarrow Y \space if \space Y=A1A2...Ak \space then X \rightarrow Ai$

$X=B_1...B_m, if A \in (X-B_i)_F^+,then \newline \space use(X-B_i) \space replace \space X \space until \space F \space cannot \space change$

$X \rightarrow A$ Let  $G = F-\{x \rightarrow A\}$, if $A \in (X)_G^+$从F中去掉该依赖

## 规范化

### 范式的概念

满足某个指定的约束集称为范式

满足最低要求的第一范式称为1NF

通过模式分解将低级范式转换为若干个高级范式的关系模式的集合，称为规范化

### 2NF

​	若$R\in 1NF$且每个非主属性完全依赖于码，则称$R\in 2NF$，即不能对码有部分函数依赖。

从1NF中消除非主属性对码的部分函数依赖就能获得2NF

2NF中允许属性部分函数依赖于码

### 3NF

不存在X、属性组Y、非主属性Z使得下式成立$X \rightarrow Y, Y\rightarrow Z, Y \not \rightarrow X$

即非主属性对码没有传递函数依赖

### BCNF

3NF没有限制主属性对码的函数依赖。

若关系模式$R<U,F> \in 1NF$如果对于R的每个函数依赖$X\rightarrow Y$且Y 不包含与X，X必含有码。

#### 性质

所有非主属性都完全函数依赖于每个候选码（左部一定是码

所有主属性都完全函数依赖于每个不包含他的候选码

没有任何属性完全函数依赖于非码的任何一组属性

## 多值依赖与第四范式

### 多值依赖

对于任一关系r，给定一组（x，z）有一组y的值相对，这组值仅仅决定于x值而与z值无关。$X \rightarrow \rightarrow Y$	

| r    | x    | y    | z    |
| ---- | ---- | ---- | ---- |
| t    | 0    | 1    | 3    |
| s    | 0    | 2    | 4    |
| w    | 0    | 1    | 4    |
| v    | 0    | 2    | 3    |

| (x,z) | y    |
| ----- | ---- |
| 0,3   | 1,2  |
| 0,4   | 1,2  |

y值变化后，z值仍然不变，满足定义。

#### 有效性范围

子集成立，全集未必成立。

全集成立，子集一定成立。

#### 性质

多值依赖具有对称性：$X \rightarrow \rightarrow Y$则$Y \rightarrow \rightarrow X$

若$X\rightarrow Y$则$X \rightarrow \rightarrow Y$ 函数依赖可以看做多值依赖的特殊情况

若$X \rightarrow \rightarrow Y$,Z为空，则称`平凡的多值依赖`，否则称其为`非平凡的多值依赖`

若$X \rightarrow \rightarrow \space Y X \rightarrow \rightarrow Z$

​	-则$X \rightarrow \rightarrow YZ$，

​	-则$X \rightarrow \rightarrow Y \and Z$，

​	-则$X \rightarrow \rightarrow Y - Z, X \rightarrow \rightarrow Z-Y$

### 4NF

对于每个非平凡的多值依赖X都含有码

不存在非平凡的非函数依赖的多值依赖

## 模式分解的理论

### 模式分解定义

函数依赖集合$F_i = \{X \rightarrow Y \in F^+ \and XY \subseteq U_i\}$称Fi为F在Ui上的投影

R<U,F>的一个分解$\rho$是指

$\rho = \{ R_1<U_1, F_1>,...,R_n<U_n,F_n>\}$

### 分解的无损连接性

定义$m_\rho (r) = \Join \Pi_{Ri}(r)$,对于任何一个关系r都有$r=m_\rho(r)$则称为具有无损连接性和无损分解。

#### 无损分解的判定算法

n行k列表 见db_b_4

#### 无损分解的判定准则

无损连接性的充要条件是$U_1 \and U2 \rightarrow U_1-U_2 \in F^+$.

即R1，R2的共同属性至少构成二者之一的候选码

### 分解的保持函数依赖性

若$F^+ (U_{i=1}^n F_i)^+$则称这个分解保持函数依赖

#### 保持函数依赖性的判定方法

R中的每个函数依赖都能够从R1...Rn函数依赖的并集中逻辑导出

### 模式分解的原则

投影分解应该遵循无损链接行和保持函数依赖

### 模式分解的算法

#### 3NF保持函数依赖的分解算法

![](/Users/horatio/Desktop/DBSpic/截屏2021-10-25 上午8.44.43.png)

#### 3NF保持无损链接与函数依赖的分解算法

![](/Users/horatio/Desktop/DBSpic/截屏2021-10-25 上午9.01.36.png)

#### BCND无损连接分解的分解算法

![](/Users/horatio/Desktop/DBSpic/截屏2021-10-25 上午9.06.49.png)

## 候选码的求解理论和算法

### 属性分类

L：只在左部的属性

R：只在右部的属性

N：左右都没有出现

LR：均出现的属性

### 快速求解候选码的充分条件

![](/Users/horatio/Desktop/DBSpic/截屏2021-10-25 上午9.16.58.png)

N类必须自己决定自己，故一定是候选码。

### 左边为单属性的函数依赖集候选码成员的图论判定方法

F是R的**单属性**、**最小依赖集**，F为边，U为点构造有向图

![](/Users/horatio/Desktop/DBSpic/截屏2021-10-25 上午9.26.41.png)

![](/Users/horatio/Desktop/DBSpic/截屏2021-10-28 下午2.06.24.png)

![](/Users/horatio/Desktop/DBSpic/截屏2021-10-28 下午2.06.28.png)

![](/Users/horatio/Desktop/DBSpic/截屏2021-10-28 下午2.06.34.png)

### 多属性依赖集候选码求解法

![](/Users/horatio/Desktop/DBSpic/截屏2021-10-28 下午1.53.51.png)

L,N的闭包不是U，所以LR里面有。

# 数据库设计

## 数据库设计概述

### 数据库设计方法

#### 手工试凑法（直接涉及法）

![](/Users/horatio/Desktop/DBSpic/截屏2021-10-28 下午2.31.59.png)

#### 规范设计法

![](/Users/horatio/Desktop/DBSpic/截屏2021-10-28 下午2.32.36.png)

## 数据库设计的基本步骤

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-07 上午10.10.10.png)

## 需求分析

### 需求分析的目标

处理要求：指用户要完成什么处理功能，对处理的响应时间和处理方式的要求。

信息要求：指系统中所涉及的数据及数据之间的联系。具体手机数据的名类型、长度等，确定数据之间的联系的类型。

安全性与完整性的要求。

### 需求分析的方法

调查用户要求

分析表达用户需求

​	用数据流图表达 数据字典描述

#### 数据流图DFD

![](/Users/horatio/Desktop/DBSpic/截屏2021-10-28 下午3.07.32.png)

#### 数据字典

![](/Users/horatio/Desktop/DBSpic/截屏2021-10-28 下午3.07.36.png)

![](/Users/horatio/Desktop/DBSpic/截屏2021-10-28 下午3.07.40.png)

**需求分析阶段**的数据字典，可看成是数据元素表

在**数据库实施阶段**建立起的数据字典，是DBMS的重要组成部分。

## 概念结构设计(important)

### E-R图

![](/Users/horatio/Desktop/DBSpic/截屏2021-10-28 下午3.25.09.png)

![](/Users/horatio/Desktop/DBSpic/截屏2021-10-28 下午3.25.09.png)

![](/Users/horatio/Desktop/DBSpic/截屏2021-10-28 下午3.25.21.png)

### 设计概念结构的四类方法

![](/Users/horatio/Desktop/DBSpic/截屏2021-10-28 下午3.26.46.png)

#### 实体模型的调整原则

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-04 下午1.51.23.png)

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-04 下午1.51.28.png)

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-04 下午1.51.34.png)

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-04 下午1.51.48.png)

## 逻辑结构设计

## E-R图向关系模型的转换规则 

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-04 下午1.53.49.png)

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-04 下午1.54.06.png)

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-04 下午1.54.12.png)

### 关系模型的规范与优化

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-04 下午2.05.49.png)

#### 水平分解

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-04 下午2.06.08.png)

#### 垂直分解

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-04 下午2.07.11.png)

#### 设计用户子模式

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-04 下午2.06.29.png)

Create View已经限制了一遍条件，故查询条件的复杂度自然会降低。

## 物理结构设计

三级模式的内模式

### 确定数据库的存储结构

#### 确定存放位置

​	经常存取部分和存取频率较低部分分开存放

​	数据和日志备份放在不同的磁盘上

#### 确定系统配置

​	确定系统配置变量、存储分配参数、进行物理优化

### 常用存取方法

#### 索引方法

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-04 下午1.56.40.png)

##### 索引存取方法的选择

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-04 下午1.56.45.png)

#### 聚集方法

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-04 下午1.57.13.png)

#### HASH文件

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-04 下午1.58.00.png)

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-04 下午1.58.03.png)

# DBMS实现技术

## 概述

### DBMS查询执行过程

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-04 下午3.13.13.png)

### DBMS数据存储与查询实现基本框架

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-08 上午8.03.32.png)

## 存储管理和索引

​	DBMS设定数据库的基本存储是在磁盘上，DBMS的组建管理内存与外存数据的交换。

​	DBMS存储管理的目标：最小化磁盘和主存间传输存储块的数量，即最小化磁盘存取次数；实现手段是在主存中保持尽量多的块，使得上层要访问一个快时，他在主存中的概率最大

### 物理存储系统

#### 磁盘

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-08 上午8.12.36.png)

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-08 上午8.12.41.png)

页面和块一般是相同的

### 数据存储结构/物理结构

#### 存储管理系统

数据库由若干文件组成，文件由若干个定长的存储单存储块、页构成。

页事存储分配和数据传输的单位

DBMS的存储管理器负责维护文件，将文件组织为块、页的集合，且

​	-跟踪页的数据读取写入

​	-跟踪可用空间

#### 物理结构

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-08 上午8.24.24.png)

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-08 上午8.24.34.png)

每条记录在单个块中

#### 数据库页/磁盘块结构

页是固定大小的数据块

​	-可以包含元组/记录，原数据，索引，log记录等

​	-每个页有唯一标识符（ID），DBMS将页ID映射为页的物理位置

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-08 上午8.30.23.png)

##### 分槽页结构

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-08 上午8.31.35.png)

槽数组从下标0往下标大的方向增加，数据空间（记录）占用从后往前，所以才会连接在一起。

故槽数据的大小不固定。

##### 记录的结构

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-08 上午8.36.11.png)

并发控制考锁机制实现。

#### 文件的记录组织

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-08 上午8.42.29.png)

##### 堆文件组织

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-08 上午8.52.14.png)

##### 顺序文件组织

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-08 上午8.55.44.png)

主要是将主码用作搜索码

##### 聚集文件组织

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-08 上午8.58.32.png)

### 缓冲区管理

**块、页**是存储分配和数据交换的单位

管理目标：最小化磁盘和贮存见传输存储块的数量，即最小化磁盘存取次数，实现手段是在主存中保持尽量多的块。

**缓冲区**：是主存中可以存储磁盘块副本的区域

**缓存管理器**：负责缓存空间分配，内外存交换

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-08 上午9.08.38.png)

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-08 上午9.11.27.png)

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-08 上午9.15.42.png)

缓冲区中的共享锁和排它锁

## 索引

### 基本概念

索引记录/索引项，是索引文件的记录，包括两个域：

​	-**索引域（搜索码，关键字）**：存储数据文件中一个或一组域（属性）

​	-**指针**：指向索引域值为K的记录所在磁盘块的地址

索引将表中的部分属性进行组织或排序，使得利用这些属性能够快速有效的进行表的访问

DBMS负责在执行查询时使用最恰当的索引。

### 索引的分类

排序索引，哈希索引，聚集索引，非聚集索引，稠密索引，稀疏索引

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-08 上午9.29.05.png)

#### 稠密索引

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-08 上午9.30.33.png)

#### 稀疏索引

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-08 上午9.30.51.png)

**文件记录是以索引域排序时可以用**

**非聚集索引都是稠密索引**

#### 多级索引

​	外层索引 内层索引

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-08 上午9.31.42.png)

##### 二叉树索引

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-08 上午9.31.47.png)



![](/Users/horatio/Desktop/DBSpic/截屏2021-11-08 上午9.31.57.png)

##### B树（平衡树索引）

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-11 上午11.17.57.png)

#### B+树

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-11 上午11.18.24.png)

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-11 上午11.18.31.png)

##### B+树的查询

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-11 上午11.18.39.png)

##### B+树的更新（插入）

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-11 上午11.18.43.png)

##### B+树的更新（删除）

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-11 上午11.18.48.png)

##### B+树的文件组织

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-11 上午11.18.52.png)

#### HASH索引

基于哈希表（HASH Table）实现

哈希表实现key到value的映射，通过键值映射到表中一个位置来访问记录，这个映射函数叫做Hash函数，存放记录的数组叫做哈希表。

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-11 上午11.24.25.png)

##### Hash方法

哈希表的实现包括两部分

​	**哈希函数**：将很大的key空间映射到比较小的域，用于计算桶、槽数组的元素序号；非用于加密算法的哈希函数；计算速度快且碰撞率低。

​	**哈希方案（scheme）**：解决一个哈希值对应多条记录（碰撞），最常使用溢出链接（Chaining）法

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-11 上午11.51.08.png)

​	**静态哈希**：哈希表的大小是固定的

​		-文件增大时，太多的溢出桶将降低访问性能

​		-数据规模缩小时，会造成空间浪费

​	**动态哈希**：允许哈希表的大小动态修改

​		-定期重哈希：创建新的大的哈希表，把原表上的key重新哈希到新表上

​		-线性哈希：以一种递增的方式重新哈希

##### Hash索引特点

​	-周期性重组的开销大

​	-适用于检索哈希码具有特定值得记录检索，不适用于区间值的检索，以及部分匹配检索

​	-有很多重复值的列，不适于做key

# 关系查询处理与查询优化

## 查询处理概述

### 关系查询处理步骤

关系查询处理的四个阶段：查询分析、查询检查、查询优化、查询执行

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-11 下午1.53.36.png)

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-11 下午1.53.41.png)

### 查询代价的度量

查询时间开销与多个因素有关

​	-磁盘访问，CPU，网络通信等

对于驻留在磁盘上的大型数据库，从磁盘访问数据的**I/O代价**通常是最重要的代价：

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-11 下午1.56.00.png)

## 查询操作的实现

### 选择运算实现算法

全表扫描法 索引扫描法

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-11 下午3.16.26.png)

### 连接运算实现算法

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-11 下午3.19.02.png)

#### 嵌套-循环法

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-11 下午3.19.06.png)

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-11 下午3.19.10.png)

每次将k-1块外表存入内存，1块内表存入内存，即每k-1块与1块对比，通过指针维护k-1块中的当前索引位置，最终每k-1会与一整个bs进行比较，故有上式。

#### 索引连接法

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-11 下午3.19.14.png)

#### 排序合并法

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-11 下午3.19.23.png)

排序的特性使得访问块数大大减少。但存在问题，当ps到d，pr到第一个d时，ps指向下一块后会使pr的第二个d块匹配不上，需要思考什么样的指针移动算法可以避免这个问题。

#### Hash Join法

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-11 下午3.19.27.png)

### 排序运算实现算法

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-11 下午3.16.34.png)

### 其他算法

去重 投影 集合运算并、差、交 库函数

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-15 上午8.02.13.png)

## 表达式的执行

可选方法包括**物化方法**和**流水线方法**。

### 物化方法

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-15 上午8.32.56.png)

### 流水线方法

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-15 上午8.33.01.png)

## 查询优化

### 查询优化的必要性

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-15 上午8.43.39.png)

2100  = (1000/10) + ((1000/10)/5) * (10000/100)

### 查询优化的目标

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-15 上午8.46.21.png)

内存代价与外存代价相比可忽略不计。

### 查询优化方法

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-15 上午8.46.40.png)

右图未考核标准，在节点上需要指明使用的物理优化内容。

#### 代数优化

**通过对关系代数表达式的等价变换来提高查询效率**

关系代数表达式的等价

​	-指用相同的关系代替两个表达式中相应的关系所得到的结果是相同的。

##### 关系代数表达式等价变换规则

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-15 上午9.07.01.png)

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-15 上午9.07.18.png)

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-15 上午9.07.24.png)

##### 查询树的优化

启发式优化：大部分情况下符合。

​	选择运算尽早执行：选择运算下沉

查询树的启发式优化(优化的一般准则)
	-**选择运算尽早执行**。是优化策略中最重要、最基本的一条。(减小中间关系-减少元组数据)
	-**投影运算尽早执行**。**(减小中间关系-减少属性数目)**
	-把投影运算和选择运算同时进行;把投影同其前或其后的双目运算结合起来。**(减少扫描关系的次数)**
	-把某些选择同在它前面要执行的笛卡尔积结合起来成为一个连接运算。**(把笛卡积与选择转换为连接)**
	-找出公共子表达式，把公共子表达式的结果写入中间文件，重复使用。**(中间结果复用)**

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-15 上午9.11.07.png)

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-15 上午9.11.15.png)

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-15 上午9.11.21.png)

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-15 上午9.26.32.png)

---

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-15 上午9.26.36.png)

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-15 上午9.26.40.png)

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-15 上午9.26.45.png)

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-15 上午9.26.51.png)

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-15 上午9.26.55.png)

进一步处理：

​	分组:双目运算和它的直系祖先(选取、投影)为一组;双目运算后代直到叶子全是单目运算时并入该组。笛卡尔积的后面若不是与之可以合并的自然连接的等值选择时，其后代单独分为一组。
​	生成查询代码时，每组节点的计算是程序中的一步。各步的顺序是任意的，只要保证任何一组的计算不会在其后代组之前计算。

#### 物理优化

选择高效合理的操作算法或存取路径。得到优化的查询计划。

常用方法：

​	-基于规则的启发式优化方法

​	-基于代价估算的优化方法

​	-两者结合的优化方法

##### 基于规则的启发式优化方法

**==选择操作==**的启发式规则：

​	-对于小关系，使用全表顺序扫描

​	-对于大关系，可以采用索引扫描法（如结果的元祖数目较小），全表顺序扫描。

**==连接操作==**的启发式规则：

​	-如果两个表都已经按照连接属性排序--排序-合并法

​	-如果一个表在连接属性上有索引--索引链接法

​	-如果连接属性上未排序其未建立索引，且其中一个表较小--Hash join法

​	-最后可选用嵌套循环法，并选择较小的表未外循环表

##### 基于代价估算的优化

利用数据库的统计信息计算各种操作算法的执行代价，选出具有最小代价的执行计划

数据库统计信息主要包括：

​	-每个基本表的规模，包括元组数、元祖长度、占用块数以及溢出块数等

​	-基本表每个列的信息，包括不同值个数、最大与最小值，是否有索引以及索引类型等

​	-索引的具体信息，例如B+树索引的层数、不同索引值个数等

### 查询优化的一般步骤

把查询转换成语法树，如关系代数语法树

把语法树利用代数优化转换成优化后的标准形式

利用基于启发式规则的物理优化，选择底层的存取路径，生成查询计划，利用基于代价的物理优化，选择代价最小的。

# 事务处理技术

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-18 下午12.42.14.png)

## 事务的概念

### 事务

**事务Transaction**是用户定义的数据库操作序列，这些操作要么都做，要么都不做，是一个不可分割的工作单位。

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-18 下午12.43.48.png)

### 事物的特性

**==原子性Atomicity==**：事务中包括的所有操作要么都做，要么都不做

**==一致性Consistency==**：事务执行的结果必须是使数据库从一个一致性状态编导另一个一致性状态

**==隔离性Isolation==**：一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对其他并发事务诗歌里的，并发执行的各个事务之间不能相互干扰

**==持久性Durability==**：一个事务一旦提交之后，他对数据库的影响必须是永久的，其他操作或故障不应该对其执行结果有任何影响。



事务的==**ACID特性**==对于数据库数据的正确、有效具有重要意义，但事务的特性有可能遭破坏，主要有两种情况：

​	-多个事务并行运行时，不同事物的操作交叉进行。I特性

​	-事务在运行过程中被强行停止。A，D特性

利用**==数据库并发控制机制以及数据库恢复机制==**保证事务的特性不被破坏，从而保证数据库数据的正确、有效
	-原子性由恢复机制实现
	-一致性是由事务的原子性保证的
	-隔离性通过并发控制机制实现
	-持久性通过恢复机制实现

==事务是数据库恢复和并发控制的基本单位。==

**==事务的开始与结束可以由用户显式控制==**。如果用户没有显式定义事务，则由DBMS按缺省规定自动划分事务。

**==事务与应用程序==**是两个概念，一般来说,一个应用程序可以包含多个事务。



### SQL中事务的定义



![](/Users/horatio/Desktop/DBSpic/截屏2021-11-18 下午12.58.10.png)

## 数据库恢复技术

### 什么是数据库恢复技术

​	-数据库管理系统必须具有==把数据库从错误状态恢复到某一已知正确状态==的功能，这就是数据库的恢复。
​	-数据库恢复是通过==数据库管理系统的恢复子系统==完成的。

	#### 数据库恢复子系统的意义

​	-==保证事务的原子性==。实现事务非正常终止时的回滚。
​	-==当系统发生故障==以后，数据库能够恢复到正确状态。	

### 数据库系统中故障的种类

#### 事务内部的故障
​	-==可预期的==:事务根据内部的测试条件，确定是否回滚。
​	-==不可预期的==:指不能由应用程序处理的事务故障，如死锁，运算溢出，违反完整性规则等。

#### 系统故障

​	-是指造成==系统停止运行==的任何事情，使得系统要重新启动。如硬件错误，操作系统故障，停电等。
​	-这类故障打断所有正在运行的事务，使==事务都异常中止，但不会破坏数据库==。

#### 介质故障

​	-介质故障指外存故障，如磁盘损坏，瞬时强磁场干扰等
​	-这类故障将==破坏全部或部分数据库==，并==影响正在存取这部分数据的所有事务==。

#### 计算机病毒

​	-计算机病毒是一种人为的破坏或故障，已成为数据库系统的主要威胁之一。
​	-多数病毒==对数据进行非法修改==。

### 恢复的实现技术

#### 故障对数据库系统的两种影响

​	-==数据库本身被破坏==，如介质故障
​	-数据库没有破坏，但==数据可能不正确==。
​		如事务故障、 系统故障，由于==事务的非法终止造成==;
​		计算机病毒

#### 数据库恢复的原理

​	-数据库恢复的基本原理为==冗余==。即利用存储在系统别处的冗余数据来重建或恢复修正数据库。

#### 数据库恢复的关键问题

​	-如何建立冗余 -> ==数据存储与登录日志文件==

​	-如何利用冗余实施数据库恢复

#### 数据转储

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-18 下午3.25.27.png)

数据转储分为两种==转储状态==

##### 静态转储

==静态转储==:系统中无事务运行时进行的转储操作。并且转储过程中，不允许对数据库进行任何存取、修改。
	优点:保证副本的数据一致性;
	缺点:由于转储必须等待正在运行的事务结束才能开始，而新的事务必须等待转储结束才能执行，降低了数据库的可用性。

##### 动态转储

==动态转储==:转储期间允许对数据库进行存取或修改。
	优点:不影响数据库的可用性
	缺点:不能保证副本上的数据正确、有效。还必须把转储期间各事务对数据库的修改记录下来，建立日志文件。==后援副本加上日志文件==就能把数据库恢复到某一时刻的正确状态。

---

数据转储可有两种==转储方式==

##### 海量转储

​	海量转储指每次转储全部数据库

##### 增量转储

​	增量转储指每次指转储上一次转储后更新过的数据

#### 日志文件的建立与使用

##### 日志文件格式与内容

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-18 下午3.27.43.png)

##### 日志文件的作用

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-18 下午3.27.47.png)

### 恢复的策略

#### 事务故障的恢复UNDO，撤销事务

在不影响其它事务的情况下,==强行回滚==，撤消已做的修改。具体步骤:
	-==反向扫描日志文件==，查找该事务的更新操作;
	-对该事务的==更新操作(插入、删除、修改)执行逆操作==，即将日志记录中的“更新前的值”写入数据库;
	-如此处理下去，==直到读到该事务的开始标志==。

#### 系统故障-UNDO+REDO

系统故障造成数据库不一致状态的原因有两个:
	-一是未完成的事务对数据库的更新可能已经写入数据库;
	-二是已提交事务对数据库的更新可能还留在缓冲区朱写入数据库。
因此恢复操作就是要==撤销(UNDO)故障发生时未完成的事务，重做(REDO)已完成的事务。==

系统故障恢复具体步骤:
	-正向扫描日志文件，找出故障发生前已经提交的事务，将其事务标识记入==重做(REDO)队列==。同时找出故障发生时尚未完成的事务，将其事务标识记入==撤销(UNDO)队列==;
	-对撤销队列中的各个事务进行UNDO处理;
	-对重做队列中的各个事务进行REDO处理。

==介质故障的恢复==，恢复的方法:
	==装入最新的数据库后备副本，使数据库恢复到最近一次转储时的一致状态。==对于动态转储的副本，还需要装入转储开始时刻的日志文件副本，将数据库恢复到一致状态;

​	==装入转储以后的日志文件副本,重做已经完成的事务。==

### 具有检查点的恢复技术

利用日志技术进行恢复时，恢复子系统通常==需要检查大量日志记录==，存在的问题是:
	-搜索日志耗费大量时间
	-不必要重做某些事务
==检查点技术==可以改善效率，使得在检查点之前提交的事务，在数据库恢复处理时不必重做。

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-22 上午8.17.49.png)

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-22 上午8.17.56.png)

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-22 上午8.18.05.png)

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-22 上午8.18.11.png)



### 数据库镜像

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-22 上午8.29.12.png)

## 并发控制技术

并发并行的区别

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-22 上午8.34.19.png)

### 为什么需要并发控制

●事务并发执行的优点
	-一个事务由不同的步骤组成，所涉及的系统资源也不同。这些步骤可以并发执行，==以提高系统的吞吐量。==
	-系统中存在着周期不等的各种事务，串行会导致难以预测的时延。如果各个事务所涉及的是数据库的不同部分，采用并发会==减少平均响应时间==。
●事务并发执行带来的问题
	-==多个事务同时存取同一数据时==，如不加控制就可能会.读取或存储不正确的数据，破坏数据库的一致性。

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-22 上午8.37.42.png)

### 并发操作导致的数据不一致性

#### 丢失更新(Lost Update)

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-22 上午8.40.25.png)

#### "脏"数据的读出（Dirty Read）

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-22 上午8.43.00.png)

#### 不能重复读(Non-Reapeatable Read)

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-22 上午8.43.50.png)

### 并发控制的主要方法

并发控制就是要==合理调度并发事务，避免并发事务之间的互相干扰造成数据的不一致性。==
并发控制的主要方法是采用==封锁机制==。

==封锁==就是事务T在对某个数据对象如表、记录等操作之前,先向系统发出请求，对其==加锁==，从而对该数据对象有了一定的控制权。
基本的封锁有两种类型:
	-==排它锁(X锁，eXclusive lock)==
	-==共享锁(S锁，Share lock)==

#### 两种基本类型封锁

##### 排它锁（X锁）

排它锁(X锁) :事务T对数据对象R加上X锁，==则只允许T读取和修改R==，其它事务对R的任何封锁请求都不能成功，直至T释放R上的X锁。

##### 共享锁(S锁)

共享锁(S锁) :事务T对数据对象R加上S锁，则事务T可以读取但不能修改R，其它事务只能对R加S锁，而不能对R加X锁,直到T释放R上的S锁。

##### 相容矩阵

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-22 上午8.58.54.png)

#### 封锁协议

运用X锁和S锁这两种基本封锁，==可以建立不同的约定,形成不同级别的封锁协议==,以保证事务并发执行过程中的数据的一致性。
	-一级封锁协议-防止丢失修改
	-二级封锁协议-防止读脏”数据
	-三级封锁协议-保证数据可重复读

##### 一级封锁协议

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-22 上午9.00.10.png)

##### 二级封锁协议

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-22 上午9.01.00.png)

##### 三级封锁协议

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-22 上午9.01.24.png)

锁小结

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-22 上午9.07.41.png)

#### 多粒度封锁

●==封锁对象的大小称为封锁粒度。==
●封锁对象:属性值、属性值集合、元组、关系、某索引项、整个索引、整个数据库、物理页、块等。
●封锁粒度大，则并发度低，封锁机构简单，开销小。
	封锁粒度小，则并发度高，封锁机构复杂，开销高。
●==多粒度封锁==:在一个系统中==同时支持多种封锁粒度==供不同的事务选择。==选择封锁粒度时应同时考虑封锁开销和并发度两个因素==，适当选择封锁粒度以达到最优效果。

##### 多粒度树

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-22 上午9.11.54.png)
多粒度封锁协议
●多粒度封锁协议==允许多粒度树中的每个结点被独立地加锁。对一个结点加锁意味着这个结点的所有后裔结点也被加以同样类型的锁。==因此，在多粒度封锁中一个数据对象可能以两种方式封锁，即:
	-==显式封锁==是应事务的要求直接加到数据对象上的封锁。
	-==隐式封锁==是该数据对象没有独立加锁，是由于其上级结点加.锁而使该数据对象加上了锁。
●在多粒度封锁方法中，==显式封锁与隐式封锁的效果是一样的。==

●多粒度封锁中存在的问题
一在多粒度封锁方法中，一般对某个数据对象加
锁，系统要做如下检查:
	-==是否与该数据对象上的显式封锁冲突==(检查对象本身);
	-==是否与该数据对象上的隐式封锁冲突==(检查对象的所有上级结点);
	-==是否与该数据对象下级的显式封锁冲突==(检查其所有下级结点)。

##### 意向锁

●==意向锁==的含义是该结点的下层结点正在被加锁
●对任意节点加锁时，必须先对其上级节点加意向锁
●意向锁的好处是:在对象加锁时，==不再检查下级结点的封锁==，只需检查对象和它的上级结点

●
三种常用的意向锁
==意向共享锁==(Intent Share Lock，简称IS锁)
	●如果要对一个数据对象加IS锁，表示它的后裔结点拟(意向)加S锁。
==意向排它锁==(Intent Exclusive Lock，简称IX锁)
	●如果要对一个数据对象加IX锁，表示它的后裔结点拟(意向)加X锁。
==意向共享排它锁==( Share Intent Exclusive Lock，简称SIX锁)
	●如果要对一个数据对象加SIX锁，表示对它加S锁，再加IX锁，即SIX= S+IX。

具有意向锁的多粒度封锁方法中，==任意事务T要对一个数据对象加锁，要先对它的上级对象结点加意向锁==，申请封锁按自上而下的次序进行;释放封锁时，应按自下而上的次序进行。

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-22 上午9.23.25.png)

#### 活锁与死锁

##### 活锁

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-25 下午2.13.11.png)

##### 死锁

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-25 下午2.13.15.png)

##### 预防死锁

一次封锁法 顺序封锁法

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-25 下午2.17.03.png)

##### 死锁的检测和恢复

超时法 等待图法

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-25 下午2.22.19.png)

### 事务的可串行化调度

#### 事物的调度

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-25 下午2.25.08.png)

#### 串行调度与并行调度

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-25 下午2.28.12.png)

#### 事务并发调度的正确性

●对并发事务中操作的调度是随机的,而不同的调度可能产生不同的结果，但==调度要保证事务执行的正确性==
●事务执行正确性的含义
	-一个事务正常的或者预想的结果是没有其它并行事务干扰时得到的结果。因此==一组事务的串行调度策略一定是正确的调度策略。==
	-虽然不同的串行顺序的结果会不同，==由于各种结果都将保持数据库数据的一致性，所以都是正确的。==

#### 并发调度的可串行性

●可串行化
	多个事务的并发执行是正确的，当且仅当其结果与==按某一次序串行执行==它们时的结果相同我们称这种调度策略为==可串行化调度==。
●可串行性是并行事务正确性的准则
	==一个给定的并发调度，当且仅当它是可串行化的，才认为是正确调度。==

#### 可串行化调度的判定

可串行化调度判定的充分条件

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-25 下午2.41.40.png)

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-25 下午2.43.07.png)

并发调度的可串行性

​	两段锁协议

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-25 下午2.55.43.png)

●==定理:若所有事务均遵从两段锁协议,则这些事务的所有并发调度都是可串行化的。==
按照这个定理，所有遵守两段锁协议的事务，其并行执行的结果一定是正确的。

==●注意的问题==

​	-事务遵守两段锁协议是可串行化调度的充分条件而不是必要条件。
​	-两段锁协议并不要求事务在执行任何数据库读、写操作之前就一次申请全部封锁，因此==遵守两段锁的事务仍可能发生死锁==。

---

# 数据库保护

## 数据库安全性控制

数据库的安全性是指保护数据库以==防止不合法的使用所造成的数据泄漏、更改和破坏==。它包括两个方面的含义:
	-向授权用户提供可靠的信息服务
	-拒绝对数据的非授权存取访问请求，保证数据的可用性、完整性和一致性，进而保护数据库所有者和使用者的合法权益



![](/Users/horatio/Desktop/DBSpic/截屏2021-11-25 下午3.02.45.png)

### 用户标识和认证

●==用户标识和认证==是系统提供的==最外层==安全保护措施。
	-==标识==是指系统采用一定的方式标识其用户或应用程序的名字或身份。
	-==认证==是指系统在用户或应用程序登录时判断其是否为合法的授权用户。
	-常用的方法是采用用户名和口令。

### 存取控制

==存取控制==确保合法用户按照指定的权限使用DBMS和访问数据，而非法用户或不具有相关权限的用户则不能。
●存取控制机制主要包括两个部分:
	==-用户权限定义:==将用户权限记录到数据字典中，形成安全规则或授权规则。

​	==-合法权限检查==，每当用户发出数据库操作请求后，DBMS根据数据字典中的安全规则进行合法权限检查,决定是否接受用户的操作请求。
​	==-用户权限定义和合法权限检查机制一起组成了DBMS的==
==安全子系统==。

### 存取控制方法分类

==自主存取控制==(discretionary access control,简称DAC)
	-用户对于不同的数据对象拥有不同的存取权限,不同的用户对同一对象也有不同的权限，而且==用户还可以将其拥有的权限转授给其他用户。==

==强制存取控制==(mandatory access control,简称MAC)
	-每一个数据对象被标以一定的密级，每一个用户也被授予某一个级别的许可证。==对于任一个对象，只有具有合法许可证的用户才可以存取。==

### 自主存取控制

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-25 下午3.09.06.png)

### SQL的数据安全性控制

在SQL中可以授予用户两类权限:

用户级权限
	-是数据库管理员为==每个用户授予的特定权限==，是对用户使用==整个数据库权限的限定==。与整个数据库相关，与数据库中具体的关系无关。

关系级权限
	-是数据库管理员或数据库对象的拥有者为用户授予的==与关系或视图有关的权限==。这种权限是对用户==使用关====系和视图权限的限定==。

### 角色与用户组

●为了管理数据库特权的方便， 数据库还支持==角色和用户组的==概念。
	-==角色是一组权限的集合，==可以把它授予用户或其他角色。当把某个角色授予用户(或角色)或从用户(或角色)处收回时，就同时授予或收回了该角色代表的全部权限。
	-==用户组是一组具有相同特性用户的集合==。在授权或收回权限时，可以以用户组为单位进行。

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-25 下午3.11.59.png)

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-25 下午3.12.03.png)

### 强制存取方法

在MAC中，DBMS所管理的==全部实体被分为主体和客体两类==。
	-==主体==是系统中的活动实体，既包括DBMS所管理的==实际用户，也包括代表用户的各进程。==
	-==客体==是系统中的被动实体，是受主体操纵的，包括文件、基本表、索引、视图等。
对于，主体和客体，DBMS为他们每个实例指定一个==敏感度标记(Label)==。敏感度标记被分为若干级别，如绝密、机密、秘密、公开等。==主体的敏感度标记称为许可证级别，客体的敏感度标记称为密级。==



MAC机制通过对==比主体的Label和客体的Label==,最终确定主体是否能够存取客体。

当某一主体以某一许可证级别注册入系统时，系统要求他对任何客体的存取必须遵循如下规则:

​	-仅当主体的许可证级别==大于或等于==客体的密级时，该主体才能==读取==相应的客体;
​	-仅当主体的许可证级别==等于==客体的密级时，该主体才能==写==相应的客体。

#### 视图

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-25 下午3.19.15.png)

#### 审计

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-25 下午3.19.18.png)

#### 数据加密

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-25 下午3.19.21.png)

### 可信计算机系统评测标准

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-25 下午3.21.15.png)

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-25 下午3.21.19.png)

## 数据库完整性控制

●数据完整性是==指数据的正确性和相容性。==
	==-正确性==是指数据应具有合法的类型，并在有效的取值范围之内。
	==-相容性==是指表示同一个事实的两个数据应该相同。
●==数据库能否保持完整性关系到数据库系统是否能够真实的反映现实世界==，因此维护数据库的完整性十分重要。

●==数据完整性控制==是为了防止数据库中存在.不符合语义的数据，防止错误信息的输入和输出;
●==数据安全性控制==是保护数据库防止恶意的破坏和非法存取;
●安全性防范的是非法用户和非法操作，完整性措施的防范对象是不合语义的数据。

### 完整性约束条件

●==施加在数据库数据之上的语义约束条件称.为数据库完整性约束条件==。数据库系统依据完整性约束条件进行完整性检查。
●==完整性约束条件作用的对象可以是列、元组、关系三种。==
	-列约束主要是列的类型、取值范围、精度等约束条件;
	-元组约束是元组中各个字段间联系的约束;
	-关系约束是若干元组间、关系之间的联系的约束。

### 完整性约束条件分类

●完整性约束可分为==静态约束和动态约束==。
	-==静态约束==是指数据库在每一==确定状态==数据对象所应满足的约束条件，它是==反映数据库状态合理性的约束==。
	-==动态约束==是指数据库从一种状态转变为另一种状态时，==新、旧值之间==所应满足的约束条件,它是==反映数据库状态变迁的约束。==

#### 静态约束

●==静态列级约束==是对一个列的取值域的说明,包括对数据类型(包括数据类型、长度、单位、精度等)、数据格式、取值范围或取值集合、空值等的约束。

●==静态元组约束==规定了组成一个元组的各个列之间的约束关系。
●==静态关系约束==规定了一个关系的若干元组或者若干关系之间常常存在的各种联系或约束。包括:实体完整性约束、参照完整性约束、函数依赖、统计约束等。

#### 动态约束

==●动态列级约束==是修改列定义或列值时应满足的约束条件;
==●动态元组约束==指修改元组值时元组中各个字段间需要满足的约束;
●==动态关系约束==是加在关系变化前后状态上的限制条件。

### 完整性控制

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-25 下午3.25.32.png)

### 完整性检查时机

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-25 下午3.25.35.png)

### 完整性规则表示

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-25 下午3.26.01.png)

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-25 下午3.26.48.png)

## SQL的数据完整性支持

### Create Table

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-25 下午3.27.33.png)

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-25 下午3.27.38.png)

### 断言

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-25 下午3.29.48.png)

### 触发器

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-25 下午3.29.53.png)

# 数据库新技术

## 概述

### 什么是数据仓库

●数据仓库(Data Warehouse)1990年提出,是==支持管理决策过程==的、==面向主题==的、集成的、随时间而增长的持久数据集合
●数据仓库中的业务
	-数据仓库上的业务处理称作==OLAP(== On-LineAnalytical Processing),即==联机分析处理==
	-数据库上的业务处理称作==OLTP==(On-LineTransaction Processing)，即==联机事务处理==

## 分布式数据库(NewSQL)

### 分布式数据库系统基本概念

==分布性==--数据分布存储在网络的各个节点上

==逻辑上的整体性==--数据被一种机制联系在一起，构成一个有机整体。

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-29 上午12.44.24.png)

●分布式数据库定义
	-分布式数据库是由一组分布在计算机网络的不同结点上的数据组成，==每个结点具有独立处理的能力(称为场地自治)，可以执行局部应用，同时每个结点也能通过网络通信支持全局应用。==
	●==局部应用:只操作一个结点上数据库的应用==
	●==全局应用:操作两个或两个以上节点上数据库的应用==

​	-分布式数据库==以数据分布为前提==,强调场==地自治性(局部应用)==以及==自治场地之间的协作性(全局应用)==，两者缺一不可。
​	●==场地自治性==:每个场地有自己的数据库、一组终端、运行局部DBMS，是独立的DBS，具有高度自治性。
​	●==自治场地之间的协作性==:各结点组成整体。整体性的含义是，从用户角度看，==分布式数据库系统逻辑上如同一个集中式数据库一样==，用户可以在任何场地执行全局应用。

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-29 上午12.48.01.png)

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-29 上午12.48.08.png)

### 分布式数据库系统的特点

​	分布式数据库系统是在集中式数据库系统技术的基础上发展起来的，它具有自己独特的特征和性质。

#### 1.数据独立性

​	数据的逻辑独立性和物理独立性

​	数据的==分布独立性（也称分布透明性）==:数据的逻辑分片、数据物理位置分布的细节、重复副本（冗余数据）一致性问题、局部节点上的数据模型等与用户程序无关

#### 2.集中与自治相结合的控制结构
​	-数据的共享有两个层次:
​		●一是==局部共享==，即在局部数据库中存储局部结点各用户的共享数据;
​		●二是==全局共享==。即在分布式数据库系统的各个结点也存储供其他结点的用户共享的数据，支持系统的全局应用。
​	-分布式数据库系统常常采用集中和自治相结合的控制结构
​		●各局部的DBMS可以独立的管理局部的数据库，具有==自治功能==。
​		●系统又设有==集中控制结构==，协调各局部DBMS的工作，执行全局应用。

#### 3.适当增加数据冗余
​	-在分布式数据库系统中适当的增加了冗余数据,==在不同的结点存储同一数据的多个副本==:
​		●==提高系统的可靠性、可用性，==当某一结点出现故障时,系统可以对另一结点的相同副本进行操作，不会因为一处故障而造成整个系统的瘫瘓;
​		●==提高系统性能==，系统可以选择用户最近的数据副本来进行操作，减少通信代价，改善整个系统的性能。
​	-不利于更新，增加了系统维护代价。

#### 4.全局的一致性、可串行性和可恢复性
​	-分布式数据库系统除了各局部数据库应满足集中式数据库的一致性、可串行性和可恢复性以外，还应保证数据库的==全局一致性、并行操作的可串行性和系统的全局可恢复性==。

### 分布式数据库系统的模式结构

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-29 上午1.00.42.png)

==全局外模式及全局外模式/全局概念模式映像(映像1)==
	全局外模式全局应 用的用户视图，是全局概念模式的子集;映像1定义全局外模式到全局概念模式的映像。
==全局概念模式==
	定义分布式数据库中数据的整体逻辑结构，使得数据如同没有分布一样。
==分片模式及全局概念模式/分片模式映象(映象2)==
	每一个全局关 系可以分为若干互不相交的部分，每一部分称为一个==片段==。==分片模式及映像2==定义片段以及全局关系到片段的映象。这种映象是一对多的。

==分布模式及分片模式/分布模式映象(映象3)==
	定义片段的存放结点及片段到节点的映象。分布模式的映象类型确定了分布式数据库是冗余的还是非冗余的。
==分布模式/局部数据库概念模式映象(映象4)==
	该映象把存储在局部场地的全局关系或全局关系的片段映象为各局部概念模式。

### 数据分片

分片的方式有多种

​	-水平分片，垂直分片--两种基本的分片方式

​	-混合分片，导出分片--较复杂的分片方式

==●水平分片==
	-将关系依照一定条件按行分为不相交的若干子集,每个子集称为一个水平片段。
==●垂直分片==
	-将关系按列分为若干属性子集,每个子集称为一个垂直片段。.垂直分片的片段通过连接的方法恢复原关系。因此垂直分片的诸片段通常都包含关系的码。
==●导出分片==
	-导出水平分片，分片的条件不是关系本身属性条件，而是其它关系的属性条件。如SC (SNO, CNO, G)按S关系中学生所在的系分片。
==●混合分片==
	-指按上述三种分片方式得到的片段，继续按另一种方式分片。

#### 数据分片的约束

无论哪种分片方式，都应满足以下条件:
==●完全性==
	-一个全局关系中的数据==必须完全划分为若干片段==，不允许某些数据属于全局关系但不属于任何片段。
==●不相交性==
	-不允许一个全局关系的某些数据既属于该全局关系的某一个片段，又属于另一个片段(垂直分片的码属性除外)。
==●可重构性==
	-可以由片段重构全局关系

​		==-垂直分片用连接操作重构==，例R的码为A，R1, R2，R3为全局关系R的垂直分片，且都包含A，则$R=R1 \bowtie R2 \bowtie R3$
​		==-水平分片用并操作重构==，例SC_ A,SC_ B为SC的两个水平分片,U则$SC=SC\_A \cup SC\_B$

### 分布透明性

​	分不透明性（分布独立性）包括：==分布透明性，位置透明性，局部数据模型透明性。==

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-29 上午1.11.55.png)

●==分片透明性-==用户或应用程序只对全局关系进行操作而不必考虑关系的分片。它是分布透明性的最高层次。
●==位置透明性-==用户或应用程序不必了解片段的存储场地也不必关心各数据副本的一致性。
●==局部数据模型透明性-==用户或应用程序不必了解局部场地上使用的是哪种数据模型。模型的转换以及查询语言等的转换均由分布模式/局部概念模式(映象4)完成。

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-29 上午1.13.00.png)

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-29 上午1.13.04.png)

### 分布式数据库管理系统DDBMS

#### DDBMS的组成

==-LDBMS(局部场地上的数据库管理系统)==Local DBMS
	●功能:建立和管理局部数据库，提供场地自治能力，执行局部应用及全局查询的子查询。
-==GDBMS (全局数据库管理系统==)Global DBMS
	●功能:提供分布透明性，协调全局事务的执行，协调各局部DBMS以完成全局应用，并保证数据库的全局一致性，执行并发控制，实现更新同步，提供全局恢复功能。
==-GDD (全局数据字典)==Global Data Dic
	●存放全局概念模式、分片模式、分布模式的定义以及各模式.之间映象的定义。
	●存放有关用户存取权限的定义，以保证全局用户的合法权限和数据库的安全性。
	●存放数据完整性约束条件的定义。
==-CM (通信管理)==
	●在分布式数据库各场地之间传递消息和数据，完成通信功能。

#### DDBMS的分类

按全局控制方式分类

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-29 上午1.16.49.png)

-全局控制分散的DDBMS
	==特点==: GDBMS分散在每一个结点上。GDD也在每个结点上有一份。这类结构称为==完全分布的DDBMS==。
	==优点==:结点独立，自治性强，单个结点出现问题不会使系统瘫瘓;
	==缺点==:全局控制的协调机制和一致性维护都比较复杂。
-全局控制部分分散的DDBMS
	●根据应用的需要将全局数据库管理器和全局数据字典.分散在某些结点上。介于上述两者之间的体系结构。

●按局部DBMS的类型分类
-同构型DDBMS
	每个结点的局部数据库具有相同的DBMS，即使硬件与操作系统不相同。
-异构型DDBMS
	各结点的局部数据库具有不同的DBMS

## 分布式数据库系统的主要技术

### 分布式查询处理和优化

​	分布式数据库系统中查询处理较集中式数据库复杂，查询优化较集中数据库更重要，效果更显著。
●分布式查询类型与处理过程
●查询优化要解决的问题
●查询优化的目标
●连接查询的优化

#### 分布式查询类型

在分布式数据库系统中，查询可分为三类:==局部查询，远程查询，全局查询。==
	-局部查询和远程查询==只涉及单个结点的数据==(本地的或远程的)，==可以采用集中式数据库的处理技术==;
	-==全局查询涉及到多个结点的数据，十分复杂。==

#### 分布式查询处理过程

为了执行全局查询和确定一个好的查询策略，要做许多判断、计算工作。
	==-查询分解==
		●把全局查询分解为若干子查询，每个子查询只涉及某一个结点的数据,可由局部DBMS处理。必须选择查询开销最省的那些结点(物理片段)。
	==-选择操作执行的次序==
		●主要是确定涉及不同结点上关系的连接和并操作的次序。
	==-选择执行操作的方法==
		●包括选择存取路径、选择某种操作的算法以及连接的执行方法。

#### 查询优化的目标

●查询处理策略的选择是以执行查询的预期代价为依据的
	==-查询执行的开销: I/O代价+CPU代价+通信代价==
●分布式查询优化可分为查询策略的分布优化和局部优化，其中分布优化更重要

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-29 上午1.23.33.png)

#### 6种可能的查询策略

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-29 上午1.24.19.png)

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-29 上午1.24.24.png)

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-29 上午1.24.29.png)

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-29 上午1.24.33.png)

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-29 上午1.24.37.png)

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-29 上午1.24.41.png)

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-29 上午1.24.48.png)

●不同的查询策略通信时间相差很大，必须进行优化;
●有些策略中数据传输时间和传输延迟都要考虑，而另一些策略主要考虑传输延迟(如问答方式)，还有一些策略数据传输量大，主要考虑传输时间。

●传送时间T=总传输延迟+总数据量/传输速度

#### 查询优化的目标

●分布式数据库查询优化中，将“通信代价”作为首要因素进行研究。因此，==查询优化的首要目标是:使查询执行时通信代价最省==。
●通信代价可计算，通常是数据传输量的函数:

​	==TC (X) =C0+X* C1==

​	==C0==为两结点初始化一次传输所花费的开销，==X==为数据传输量，==C1==为传输率，即单位数据传输所花费的时间。
​	==不同结点之间的连接操作和并操作是数据传输的主要原因，因此连接查询的优化是优化中研究的重要问题。==

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-30 下午10.02.56.png)

==半连接==:使用半连接来缩减关系(或片段)进而节省传输开销。

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-30 下午10.03.56.png)

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-30 下午10.04.14.png)

### 分布事务处理

●分布事务的原子性与可串行性
	-在分布式数据库系统中，====一个全局事务被划分为在许多结点上的子事务。==
	-==分布事务的原子性是:组成该事务的所有子事务要么一致地全部提交，要么一致地全部回滚。==
	-在多用户系统中，还必须保证分布式事务的可串行性。
●分布事务管理主要包括:事务的恢复和并发控制。

#### 分布事务的恢复

●每个场地都有一个==局部事务管理器==，负责管理局部子事务的执行。同时==各局部事务管理器之间必须相互协调，保证分布事务的原子性:==各子事务要么都提交，要么都回滚。
●对局部事务管理器进行协调，保证分布事务原子性最常用的技术-==两段提交协议==( 2- Phase-Commitment Protocol)

#### 两段提交协议

●两段提交协议把一个分布事务的所有局部事务管理分为两类:==协调者(一个)，参与者==。
	==-协调者==:负责作出该事务是提交还是撤消的最后决定。
	==-参与者==:负责管理相应子事务的执行以及在各自局部数据库上执行写操作。

●两段提交协议内容
	==-第一阶段:协调者征求意见作决定==
		●协调者向所有参与者发出“准备提交”信息，并记入日志;参与者准备提交就回答“就绪”，否则回答“撒消”，并记入日志。
		●如果在规定时间内，协调者收到所有参与者的“就绪”信息,则作出“提交”决定，否则将作出“撤消”决定。
	==-第二阶段:参与者执行决定==
		●协调者将有关决定写入日志，然后把这个决定发送给所有的参与者。
		●所有参与者收到命令后，首先在日志中记入“收到提交/撤消决定”的信息，并向协调者发送应答消息，最后执行相应决定。
		●协调者收到所有参与者的应答消息后，一个事务的执行到此结束。有关日志信息可以脱机保存。


●采用两段提交协议后，当系统发生故障时，各场地利用
各自有关的日志进行事务恢复。

#### 并发控制

●分布式数据库系统中的并发控制也可以采用封锁技术，但并发控制更加复杂:
	-分布式数据库系统支持多副本;
	-由于事务的分布执行，封锁的方法会引起全局死锁。

●分布式数据库系统并发控制进一步的策略:
	-处理多副本封锁的几种可行方法:
		●对写操作，要申请所有副本的X锁;对读操作，只要申请某个副本的S锁。
		●无论是写操作还是读操作都要对大多数副本申请X锁或S锁。
		●规定某个场地上的副本为主副本，所有的读、写操作均申请对主副本的封锁。
	-解决全局死锁(两个以上场地上发生死锁)
		●死锁检测及解除方式

​		●死锁预防，如对事务按某一标准进行排序，只允许事务按这一次序单向等待。



---

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-30 下午10.10.49.png)
