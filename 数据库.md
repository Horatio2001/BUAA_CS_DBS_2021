##  数据管理技术的发展

数据的独立性是数据库系统的最基本的特征之一 。数据独立性是指应用程序数据结构之间相互独立, 互不影响。在三层模式体系结构中数据独立性是指数据库系统在某一层次模式上的改变不会使它的上一层模式也发生改变的能力。正是三级模式间的两层映像保证了数据库系统中的数据具有较高的数据独立性。数据独立性包括数据逻辑独立性和数据物理独立性。 

DBMS负责数据的物理结构和逻辑结构，应用程序只关注如何使用。

描述数据本身时还要描述数据之间的联系，使整个组织数据结构化。数据结构化是数据库主要特征之一，是数据库与文件系统的根本区别，

### 数据库系统管理特点：

1.数据冗余度小，易扩容

2.数据库系统具有较高的数据和程序独立性

​	`数据`的物理独立性是指数据的存储结构改变时，数据的逻辑结构可以不变，不影响应用程序。

​	`数据`的逻辑独立性是指数据的逻辑结构改变时，应用程序可以不变。

​		数据库系统提供了两方面的`映像（转换）`功能：

​			数据的存储结构与逻辑结构之间的映像：实现数据的物理独立性。（内模式）

​			数据的全局逻辑结构与某类应用所设计的局部逻辑结构之间的映像：实现数据的逻辑独立性。（外模式）

3.统一的数据控制功能

​	- 数据的`安全性`控制

​		保护数据防止不合法的使用造成数据的泄密和破坏。

​	- 数据的`完整性`控制

​		指数据的正确性与相容型。

​	- 并发控制

​		对多用户的并发操作进行控制、协调，保护数据的完整性。（事务处理技术）	

​	- 数据库恢复

​		将数据库从错误状态恢复到某一已知的正确状态。

4.数据的最小存取单位是数据项

​	- 既可以存取一个或一组记录，也可以数据库中某个或一组数据项。

### 模型

分为两个层次：1.概念模型（信息模型） 2.数据模型（层次、网状、关系模型）

概念模型最常用的表示方法：实体-联系方法（E-R）法

### 概念模型的基本概念

实体（Entity）：客观存在的可以区分的事物

属性（Attribute）：实体所具有的某一特性；

码（Key）：唯一标识实体的属性集；

域（domain）：某个（些）树形的取值范围；

实体性（Entity Type）：表示一类实体，用实体名及其属性姓名集合来抽象刻画。

联系（Relation）：实体型之间的联系，是实体之间的相互关联。

​	-名称

​	-类型 ： 一对一联系 一对多联系 多对多联系

​	-可以具有属性

## 概念模型

联系具有名称、类型，可以具有属性。

如`学生`和`课程`之间的联系属性为多对多，名称为`选修`，选秀的一个属性为`成绩`

e-r图的组成：实体、联系、属性

​	-实体：长方形

​	-属性：椭圆形，无向边变把实体与其属性连接起来。

​	-联系；菱形，无向边联系菱形及其有关实体相连，再无向边旁标上联系的类型，若联系有属性则同上。

同一个实体内补各实体之间也可以存在联系，多实体之间可以存在联系，两实体之间可以存在多种联系。

### E-R图语义扩充

1.存在依赖：E，如子女实体存在依赖于职工实体，则其为弱实体。

2.标识依赖：实体不能由自己的属性来唯一标识，二必须通过与他相联系的另一实体一起来标识，那么称该实体标识依赖于另一个实体。

3.实体的子类：子类可以继承父类的属性 子嘞也可以附加某些属性 子类之间的交不一定为空

### 概念模型实例（E-R）

根据需求描述确定实体、关系、属性。

## 数据模型

数据模型是严格定义的概念集合，这些概念精确的描述系统中数据的静态特性、动态特性和完整性约束。

数据模型的三要素：`数据结构` `数据操作` `完整性约束`

### 数据结构

数据结构由描述数据对戏那个以及对象之间联系的一组概念组成 包括：

​	-描述对象的类型、内容、性质的概念，入关系中的域、属性等

​	-描述对象之间联系的概念，如关系模型中的关系

是数据静态特性的描述

数据结构是刻画数据模型最重要的方面，通常根据数据结构的类型来命名数据模型（关系数据模型的数据结构就是关系）

### 数据操作

定义操作的确切含义、操作符号、操作规则及操作语言；

是数据动态特性的描述

数据库主要有检索和更新（插入、删除、更改）

### 约束条件

是完整性规则的集合，完整性规则是给定的数据模型中，数据及其联系所有的制约和依存规则，用以保证数据的正确、相容

完整约束条件包括：

​	-符合这种税局模型所必须遵守的基本的通用的完整性约束条件。

​	-针对具体数据的特定语义的约束条件。

## 数据模型的分类

层次模型、网状模型、关系模型

### 层次模型

树状图，有向树，结点代表实体型，连线表示两实体型间的一对多联系

​		特征：有且仅有一个结点没有双亲，其他结点有且仅有一个双亲

​		缺点：无法表示多对多关系

### 网状模型

图结构，有向图，结点代表实体型，连线标识两实体型间的一对多联系

​		特征：表达联系种类丰富，结构复杂

### 关系模型

```二维表```，用二维表格结构来表示实体及其实体之间的联系

## 数据库系统结构

具有三级模式两级映像

### 模式

也称为逻辑模式和概念模式，是数据库中全体数据的逻辑结构和特性的描述，是所有用户的公众数据视图。

是三级模式的核心，不涉及存储细节和编程

具体定义数据的逻辑结构、数据安全性、完整性要求

数据库系统提供模式描述语言（模式DDL）

### 外模式

也称为子模式或用户模式，即与某一应用有关的数据的逻辑表示

通常是模式的子集，不同应用的外模式可以相互覆盖，一个应用只能启用一个外模式

数据库系统提供外模式描述语言（外模式DDL）

### 内模式

物理模式、存储模式，对于数据的物理结构和存储方式的描述

数据库系统提供外模式描述语言（外模式DDL）

### 三级模式的结构优点

保证数据独立性

​	-模式与内模式分开 数据物理独立性

​	-外模式与模式分开 数据逻辑独立性

简化用户接口 方便用户使用

​	-用户只按照外模式操作 无需了解数据库的总体逻辑结构与物理存储结构

有利于数据共享

​	-从模式产生不同的外模式 外模式间可相互覆盖

有利于数据的安全保密

​	-应用程序只能操作其对应的外模式

## DBMS

### 主要功能

数据存取功能

​	-提供DML语言 对数据库进行检索 插入 修改 删除

数据库运行管理

​	-并发控制、存取控制、完整性约束条件检查和执行、日志组织和管理、事务管理和自动恢复

数据组织、存储和管理

​	-用户数据、缩影、数据字典的组织、存储和管理，包括文件结构、存取方式、数据之间联系的实现等

数据库建立和维护

​	-数据的装入、转换，数据库的转储、恢复、性能件事和分析

### 组成

DDL DML DCL

语言编译处理程序

系统运行控制程序

​	-包括系统总控、存取控制、并发控制、完整性控制、保密性控制、数据存取和更新、通信控制等程序。

系统建立和维护程序

​	-数据装入、数据库系统恢复、性能监督、工作日志等程序。

数据字典

​	-也称为数据目录或系统目录，由一系列表组成，存储着数据库中有关信息的当前描述，包括数据库的三级模式、用户名表、用户权限等信息。

​	**“元数据：描述数据的数据”**

## DBA

建库方面

​	-确定模式、外模式、存储结构、存取策略、负责数据的整理和装入

用库方面

​	-定义完整性约束条件，规定数据的保密级别、用户权限，监督和控制数据库的运行情况，制定后院和恢复策略，负责故障恢复

改进

​	-监督分析系统的性能（空间利用率，处理效率）

​	-数据库冲组织，物理上重组织，以提高性能

​	-数据库冲构造，设计上较大改动，模式和内模式修改



# 2.关系数据库

## 关系数据库

### 数学定义

元组：n个域参与的笛卡尔积成为n元组，元组中的每一个值叫做一个分量。

### 关系的定义

笛卡尔积的子集叫做在域D1...Dn上的关系，用R(D_1,D_2,...,D_n)表示，R是关系的名字，n是度或者目

### 关系可以表示为二维表

​	-表的框架由域构成

​	-表的每一行为元组 每一列为域

​	-每个列附加一个名称，称为`属性`	属性的名字是唯一的

### 关系的性质

​	-列是同质的，来自同一个域

​	-不同的列可出自同一个域 但不能有相同的属性名

​	-列的顺序无所谓

​	-任意两个元组不能完全相同

​	-行的顺序无所谓

​	-每一分量必须是不可再分的数据 满足这一条件的关系称作满足`第一范式（1NF）`的

 ## 关系模型的数据结构

关系模型的数据结构：关系

### 几个基本概念

#### 码(Key)

​	-候选码：关系中的某一属性组，若他得知唯一的表示了一个元组，并具有最小性(如果去掉某个属性仍能唯一标识 就不满足最小性)，则称该属性组为候选码

​	-主码：若一个关系有多个候选码，则选定其中一个为主码

​	-候选码中的主属性称为主属性，不包含在任何候选码中的属性称为非主属性。

#### 关系模式

​	关系的描述，`R(U,D,dom,F,I)`，其中`U`为组成该关系的属性名集合 `D`为属性集U的域 `dom`为属性向域的映像集合 `F`为属性间的依赖关系集合 `I`为完整性约束集合·

​	关系模式通常可以记作R(A~1~,A~2~,...,A~n~)，R为关系名，A~1~...A~n~为属性名，D和dom直接说明为属性的类型、长度。

​	关系是关系模式在某一时刻的状态或内容。关系模式相对稳定的，而关系是动态的，是随时间不断变化的

#### 关系数据库

​	关系模式的集合构成关系数据库模式-关系数据库的型

​	关系的集合则构成具体的关系数据库-关系数据库的值

## 关系模型的语义约束

实体完整性和参照完整性是关系模型必须支持的约束条件。

### 实体完整性

​	– 要有属性或属性组合作为主码，主码值不可为空或部分为空。或定义为若属性A是关系R的主属性，则属性A不能取空值。

​	– 空值的含义是：不知道或不存在的值。

### 参照完整性

#### 外部码

​	设F是`基本关系R`的一个或一组属性，但不是R的码，如果F与基本关系S的主码Ks相对应，则称F是关系R的`外部码`，并称R为`参照关系`，S为`被参照关系`或`目标关系`。R和S不一定不同。

​	目标关系S的主码Ks和参照关系的外部码F必须定义在一个域上。

#### 参照完整性

​	如果关系R的外部码F~k~与关系S的主码P~k~相对应，则R中的每一个元祖的F~k~值或者等于S中某个元组的P~k~值，或者为空。

## 关系模型的数据操作

​	-特点是集合操作，一次一集合方式。

​	-关系数据操作的基础是关系运算，主要有两种：代数方式，逻辑方式。

### 关系代数简介

常规集合运算：并、差、交、广义笛卡尔积（乘）

特有关系运算：选择、投影、连接、自然连接、求商

### 关系演算简介

${\{t|\Phi(t)\}}$t为元组变量${\Phi(t)}$是元祖关系演算公式。

域关系演算表达式的形式

${\{(x_1,x_2,...,x_k)|\Phi(x_1,x_2,...,x_k)\}}$

其中x~i~代表域变量，$\Phi$为域关系演算公式。

## 关系代数

### 广义笛卡尔积

​	关系R、S度为n，m，笛卡尔积为元组集合，前n个分量是R中的一个元组，后m个分量是S中的一个元组，R*S的度为（n+m），

### 选取或限制

​	在关系R中选择满足给定条件的元组。记作：

​	${\sigma_F(R)=\{t|t\in R,F(t)='真'\}}$

​	如F：S#=1923

### 投影

​	从关系R（U）取若干属性列并删除重复行组成新的关系

​	${\Pi_A(R)=\{t[A]|t\in R,A\subseteq U\}}$

​	如A：S#

### 连接

​	关系R和S在属性X和Y上的连接（X、是连接属性，即X、Y包含同等数量的属性，且相应的属性均具有共同的域），是从两个关系的广义笛卡儿积R中选取给定属性(X和Y)间满足$\theta$比较条件的元组。

​	${R \Join S=\{t|t=<r,s> \land r \in R\land s\in S \land r[X]\theta s[Y]\}}$

​	$\theta$为比较条件，

​	$\theta$为=时，成为等值连接

​	$\theta$为<时，为小于连接

​	$\theta$为>时，为大于连接

当前表中没有必要的属性时，就需要与其他表进行连接。

### 自然连接

​	在等值连接的情况下，连接属性X和Y是相同属性时候。

​	需要在等值连接结果基础上在进行投影运算，去掉重复的属性列。

### 除法

​	R（X，Y）与关系S（Z），其中Y和Z具有相同的属性数，且对应属性出自相同域，关系R除以关系S所得的商关系是关系R在属性X上投影的一个子集，该自己和S（Z）的笛卡尔积必须包含R（X，Y）中。

​	${R\div S=\{t|t \in \Pi_x(R)\land s\in S\land <t,s>\in R\}}$

## 元组关系演算与域关系演算

元组为变量则为元组关系演算

域为变量则为域关系演算

### 元组关系演算公式的递归定义

#### 原子公式

原子公式有三类：

​	-R（t）元组

​	-t[i]$\theta$u[j] 分量的比较关系

​	-t[i]$\theta$c or c$\theta$t[i] 与常数的比较关系

#### 优先次序

算数比较符最高

量词次之，存在高于任意

逻辑运算符最低，非高于且，且高于或

### 元组演算与关系代数的等价性

关系演算可以表达五种基本关系运算。

### 域演算公式的递归定义

域公式有三类：

​	-R（x1,x2...）元组

​	-xi$\theta$xj 分量的比较关系

​	-xi$\theta$c or c$\theta$xi 与常数的比较关系		

### 关系运算的安全约束

​	把不产生无限关系和无穷验证的运算称为安全运算，其运算表达式称为安全表达式，对其所采取的限制称为安全约束。

​	关系代数一定是安全运算，关系演算不一定是，所以对关系演算要进行安全约束。

​	通常采用的安全约束方法是对$\Phi$定义一个有限的符号集DOM（$\Phi$），使$\Phi$的运算结果及其中间结果所产生的关系及其元组的各个分量都必须属于DOM（$\Phi$）。

## 关系数据语言概述

### 数据库数据语言

​	-数据描述语言DDL

​		包括模式DDL，外模式DDL，内模式DDL

​	-数据操纵语句DML

​		增删改查

​	-数据控制语言DCL

​		负责完成数据库的安全性控制、完整性控制、并发控制等。

### 关系数据语言特点

​	-一体化

​		将数据的定义、查询、更新、控制等功能融为一体，只给用户提供一种称之为查询语言的语言，便于用户学习。

​	-非过程化

​		用户只需提出干什么，怎么解决由DBMS负责

​	-面向集合的存取方式

​		操作对象是一个或多个关系，操作的结果也是一个新关系

即可

​	-既可以独立使用 又可以嵌套

### 关系数据语言的分类

​	关系数据语言的核心是查询，所以又称为查询语句，而查询往往表示成一个关系运算表达式，因此关系运算时基础关系运算的分类也决定了关系语言的分类。

# 3.关系数据库标准语言SQL

## SQL特点

​	-综合统一

​	-高度非过程话

​	-面向集合的操作方式

​	-以同一种语法结构提供两种使用方式

​	-语言简洁，易学易懂

| SQL功能 | 操作符               |
| ------- | -------------------- |
| 查询    | Select               |
| 定义    | Create,drop,alter    |
| 操纵    | insert update delete |
| 控制    | Grant revoke         |

## SQL语言的基本概念

### 基本表与导出表

​	- 基本表：实际存在的表，每个表再存储中可用一个存储文件来表示

​	- 导出表：从基本表导出的表，有视图(view)和快照(snapshot)。

​		-视图是一个虚表，即视图所对应的数据不实际存储在数据库中，只在数据库的数据字典中存储视图的定义。

​		-视图一经定义就可以和基本表一样进行查询等操纵，也可以用来定义新的视图

## SQL数据查询功能

查询的基本结构是select-from-where组成的查询块

​	SELECT 目标列

​	FROM 基本表（或视图）

​	WHERE 检索条件

### 投影检索

采用DISTINCT消去结果中的重复行

```sql
SELECT DISTINCT C#

FROM SC;
```

### 选取检索

由WHERE字句指出查询条件

检索条件包括比较运算符、布尔运算符（AND OR NOT）、（）

```sql
# 检索成绩在70到85之间的学号课号和成绩
	SELECT S#, C#, G
	FROM SC
	WHERE G BETWEEN 70 AND 85
```

### 排序检索

​	在SELECT-FROM-WHERE查询块后接OERDER BY子句

​	格式：ORDER BY 列名 ASC（升序） 或 DESC（降序）

​	default为升序

​	可以是单列或多列排序

​	该子句在SELECT语句中作为最后一个子句出现

```sql
# 检索全体学生信息，并按系号升序，同一个系按年龄降序排列
	SELECT *
	FROM S
	ORDER BY SD, SA DESC
```

### 连表检索

把相互关联的表连接起来，实现多表数据检索。

```sql
SELECT #指明选取的列名 来自多个表
FROM  #指明要链接的表名
WHERE #指明连接条件与选取条件
```

连接条件一般如下：

$ [<表名>.]<列名><比较运算符>[<表名>.]<列名>$

```sql
# 检索学生张华所学课程的成绩
	SELECT SN, C#, G
	FROM S, SC
	WHERE S.S#=SC.S# AND SN=‘张华’
```

#### 表自身的连接

还可以通过定义别名，将一个表看成两个表，进行连接

```sql
# 检索所有比李永年龄大的学生姓名 年龄
	SELECT X.SN, X.SA
	FROM S X, S Y
	WHERE X.SA>Y.SA AND Y.SN = ‘李永’
```

#### 外连接

​	在连接谓词某一边家（\*或\+），则逻辑上为\*所在变的表增加了一个空行。它可以与另一个表中所有不满足连接条件的元组进行连接，使这些元组能够输出。

```sql
# 检索所有学生的全部信息
	SELECT *
	FROM S, SC
	WHERE S.S#=SC.S#(*);
```

### 子查询嵌套检索

​	where子句可以包含另一个查询块，该查询块称为`子查询`或者`嵌套查询`，包含子查询的语句称为`外部查询`。

​	外部查询利用子查询来获取检索条件的条件值，检索条件根据自查询的结果来确定外部查询的结果数据

​	子查询按照与外部查询的联系不同，分为普通子查询和相关自查询

​		-普通子查询：与外部查询无关，可单独执行得一组值

​		-相关子查询：把外查询的列值作为检索条件的条件值

```sql
SELECT
FROM A
WHERE(SELECTED FROM B WHERE B.X < A.Y)
```

#### 涉及同一个表的子查询

```sql
# 检索与李永同岁的学生姓名
	SELECT SN
	FROM S
	WHERE S.SA = 
			(SELECT SA FROM S 
				WHERE SN = ‘李永’);
```

​	子查询返回单值，可以直接用比较运算符查询，如果返回一组值，则必须在比较运算符和子查询之间插入ANY、ALL等操作符。

```sql
# 检索选修C2课程的学生姓名
	SELECT SN
	FROM S
	WHERE S#=ANY
		(SELECT S# FROM SC
			WHERE C#='C2');
```

```sql
# 检索选修C2课程的成绩最高的学生学学号
	SELECT S#
	FROM SC
	WHERE C#='C2'AND
		G>ALL
			(SELECT G FROM SC
				WHERE C#='C2');
```

#### 用IN检索

​	in可代替“=ANY”，是集合运算中的"$\in$"运算。

```sql
# 检索选秀C2课程的学生姓名
	SELECT SN
	FROM S
	WHERE S# IN 
		(SELECT S# FROM SC
			WHERE C#='C2');
```

#### 用NOT IN检索

​	NOT IN表示不再集合中，与！=ALL相同。

#### 用EXISTS检索

​	$\exists$,当且仅当子查询结果非空时为真。

```sql
# 检索选修C2课程的学生姓名
	SELECT SN
	FROM S
	WHERE EXISTS
		(SELECT * FROM SC
		WHERE S#=S.S# AND C#='C2')
```

#### 用NOT EXISTS检索

​	表示不存在，在子查询结果为空时为真。

##### 用NOT EXISTS表达全称量词$\forall$

​	$(\forall x)P = \neg (\exists x (\neg P))$即用NOT eXISTS表达全称量词

```sql
# 检索选秀所有课程的学生姓名
	SELECT SN
	FROM S
	WHERE NOT EXISTS
		(SELECT * FROM C
		WHERE NOT EXISTS
			(SELECT * FROM SC
			WHERE S#=S.S# AND C#=C.C#))
# 即查找不存在他没选修的课程的学生
```

##### 用NOT EXISTS表达蕴含

$(\forall y)p \rightarrow q = \neg \exists y(p \and \neg q) $ 

```sql
# 检索至少选修了学生S2选修的全部课程的学生学号
	SELECT DISTINCT S#
	FROM SC SCX
	WHERE NOT EXISTS
		(SELECT * FROM SC SCY
		WHERE SCY.S#='S2' AND NOT EXISTS
			(SELECT * FROM SC SCZ
			WHERE S#=SCX.S# AND C#=SCY.C#))
```

### 并、差、交检索

UNION MINUS INTERSECT

```sql
# 检索选修了C1或C2课程的学生学号
	SELECT S# 
	FROM SC
	WHERE C#=C1'
	UNION
	SELECT S# 
	FROM SC
	WHERE C#='C2'
```

```sql
# 检索无人选修的课程号和名称
	SELECT C#, CN FROM C WHERE C# IN
		(SELECT C# FROM C
		MINUS
		SELECT DISTINCT C# FROM SC)
```

### 库函数检索

COUNT()按列值计数，COUNT（*）对行计数

SUM()对数值列求和

AVG()求数值列平均值

MAX()在列中找最大值

MIN()在列中找最小值

只能在SELECT字句和HAVING字句中出现

```sql
# 检索学生总数
	SELECT COUNT(*) FROM S
```

```SQL
# 检索选秀了课程的学生人数
	SELECT COUNT(DISTINCT S#) FROM SC
```

```sql
# 求学号为S4的学生的总分和平均分
	SELECT SUM(G),AVG(G)
	FROM SC
	WHERE S#='S4'
```

```sql
# 检索选修了C1课程的学生最高分
	SELECT MAX(G) FROM SC WHERE C#='C1'
```

### 分组检索

按属性列将关系的元组分组，每组在这些分组属性列上具有相同值，对每一组执行SELECT操作

分组字句：

​	GROUP BY 列名

​	[HAVING 条件表达式] ——分组条件

```sql
# 检索至少选秀三门课程的学生学好和选课门数
	SELECT S#, COUNT(*)
	FROM SC
	GROUP BY S#
	HAVING COUNT(*) >=3
```

```sql
# 求选修四门以上课程的学生学好和总成绩（不统计不及格的课程）最后按降序列出总成绩排序名单
	SELECT S#, SUM(G)
	FROM SC
	WHERE G>=60
	GROUP BY S#
	HAVING COUNT(*)>=4
	ORDER BY SUM(G) DESC
```

### 算术表达式值的检索

```sql
# 有职工表EMP（EMP#，EMPN，JOB，SALARY，BONUS，DEPT）要求检索所有PROGRAMMER的奖金大于工资25%的职工姓名和一年的总收入，并按奖金与工资之比的降序排列
	SELECT EMPN, BOUNS/SALARY BS,
		12*(SALARY+BONUS) TOTAL
	FROM EMP
	WHERE JOB='PROGRAMMER'
		AND BONUS>0.25*SALARY
	ORDER BY BONUS/SALARY DESC
```

### 部分匹配查询

%：代表任意序列的0个或多个字符

_：代表任意单个字符

# 4.关系数据理论

## 数据依赖的概念

一个关系内部属性值之间相互依赖又相互制约的关系称为数据依赖。分为两种，函数依赖和多值依赖。

## 函数依赖

### 函数依赖的定义

设R(U是属性集U上的关系模式X、Y是U的子集。r是R的任意一个具体关系，t , s 是r中任意两个元组。如果t[X] = s[X]，则[Y] = s[Y]，则称“X函数确定Y”或“Y函数依赖于X”，记作：$X \rightarrow Y$

即X的每个具体值，Y有唯一的值与之对应。

#### 函数依赖相关术语

平凡与非平凡的函数依赖：若$Y \subseteq X $则为平凡依赖，一般是不平凡的。

对于$x \rightarrow y$把x称为决定因素

#### 函数依赖与属性间的联系类型

##### 一对一联系

如学生学号与身份证号

$X \rightarrow Y, Y \rightarrow X$

##### 一对多联系

如学生所在系的系名与学号

只存在$Y \rightarrow X$

##### 多对多联系

如学号与课程名

不存在函数依赖

### 三种函数依赖

#### 完全函数依赖与部分函数依赖

任意真子集都不能推出则是完全依赖。***箭头上面f是完全 p是部分 t是传递***

#### 传递函数依赖

在R(U)中，如果$X \rightarrow Y, Y \rightarrow Z$，且$Y \not \rightarrow X$，则称为Z对X传递依赖。

### 关系键的形式定义

K为属性或组合，若U对K完全依赖则K为候选码，不包含在任何码的属性称为非主属性

### 函数依赖公理系统

#### 函数依赖的逻辑蕴含

关系模式R<U,F>中，X，Y是属性，从F中的函数依赖能够推出$X \rightarrow Y$则称F逻辑蕴含$X \rightarrow Y$。

##### 函数依赖集F的闭包

为F所逻辑蕴含的函数依赖的全体称为F的闭包，记作$F^+$

#### Armstrong公理及推论

##### A1自反律

若$Y \subseteq X \subseteq U$，则$X \rightarrow Y$为F所蕴含

##### A2增广律

若$X \rightarrow Y$为F所蕴含，且$Z \subseteq U$则$XZ \rightarrow YZ$为F所蕴含

##### A3传递律

若$X \rightarrow Y， Y \rightarrow Z$为F所蕴含，则$X \rightarrow Z$为F所蕴含

##### 合并规则

若$X \rightarrow Y， Y \rightarrow Z$有$X \rightarrow YZ$ 

##### 伪传递规则

$X \rightarrow Y, WY \rightarrow Z$有$XW \rightarrow Z$

##### 分解规则

由$X \rightarrow Y, Z \subseteq Y$有$X \rightarrow Z$

##### 定理一

$X \rightarrow A_1 A_2 ... A_k等价于X \rightarrow A_i成立$

#### 属性集的闭包

$X \rightarrow Y, 等价于Y \subseteq X_F^+$

##### 闭包的计算

---

Input:X, F

OutPut:$X_F^+$

$X_F^+$:=X;

do

​	for any $A \subseteq X_F^+ $do

​		if在F中存在函数依赖$A \rightarrow B$

​			then $X_F^+$=$X_F^+ \or B$

While($X_F^+$发生变化且$X_F^+ \not = U$)

---

#####  Armstrong是有效的完备的

F出发推出来的函数依赖一定在F所蕴含的函数依赖全体中

F元含的函数依赖的全体中的每一个函数依赖，必定可以有F推出

#### 函数依赖集的最小依赖集

##### 函数依赖集等价

闭包相等则称为等价，同时相互覆盖。

##### 最小依赖集

F中任意函数依赖$X \rightarrow A$，A必是单属性（右部单属性化

F中不存在$X \rightarrow A$使得F与$F - \{ X\rightarrow A\}$等价（没有多余的FD

F中不存在$X \rightarrow A$，在X中有真子集Z使得F与$F-\{X \rightarrow A\}\or\{Z\rightarrow A\}$等价（FD左部没有多余属性（把XA换成ZA

##### 极小化处理

每个函数依赖集F均等价于一个极小函数依赖集Fm，Fm为F的最小依赖集

##### 极小化算法

$X \rightarrow Y \space if \space Y=A1A2...Ak \space then X \rightarrow Ai$

$X=B_1...B_m, if A \in (X-B_i)_F^+,then \newline \space use(X-B_i) \space replace \space X \space until \space F \space cannot \space change$

$X \rightarrow A$ Let  $G = F-\{x \rightarrow A\}$, if $A \in (X)_G^+$从F中去掉该依赖

## 规范化

### 范式的概念

满足某个指定的约束集称为范式

满足最低要求的第一范式称为1NF

通过模式分解将低级范式转换为若干个高级范式的关系模式的集合，称为规范化

### 2NF

​	若$R\in 1NF$且每个非主属性完全依赖于码，则称$R\in 2NF$，即不能对码有部分函数依赖。

从1NF中消除非主属性对码的部分函数依赖就能获得2NF

2NF中允许属性部分函数依赖于码

### 3NF

不存在X、属性组Y、非主属性Z使得下式成立$X \rightarrow Y, Y\rightarrow Z, Y \not \rightarrow X$

即非主属性对码没有传递函数依赖

### BCNF

3NF没有限制主属性对码的函数依赖。

若关系模式$R<U,F> \in 1NF$如果对于R的每个函数依赖$X\rightarrow Y$且Y 不包含与X，X必含有码。

#### 性质

所有非主属性都完全函数依赖于每个候选码（左部一定是码

所有主属性都完全函数依赖于每个不包含他的候选码

没有任何属性完全函数依赖于非码的任何一组属性

## 多值依赖与第四范式

### 多值依赖

对于任一关系r，给定一组（x，z）有一组y的值相对，这组值仅仅决定于x值而与z值无关。$X \rightarrow \rightarrow Y$	

| r    | x    | y    | z    |
| ---- | ---- | ---- | ---- |
| t    | 0    | 1    | 3    |
| s    | 0    | 2    | 4    |
| w    | 0    | 1    | 4    |
| v    | 0    | 2    | 3    |

| (x,z) | y    |
| ----- | ---- |
| 0,3   | 1,2  |
| 0,4   | 1,2  |

y值变化后，z值仍然不变，满足定义。

#### 有效性范围

子集成立，全集未必成立。

全集成立，子集一定成立。

#### 性质

多值依赖具有对称性：$X \rightarrow \rightarrow Y$则$Y \rightarrow \rightarrow X$

若$X\rightarrow Y$则$X \rightarrow \rightarrow Y$ 函数依赖可以看做多值依赖的特殊情况

若$X \rightarrow \rightarrow Y$,Z为空，则称`平凡的多值依赖`，否则称其为`非平凡的多值依赖`

若$X \rightarrow \rightarrow \space Y X \rightarrow \rightarrow Z$

​	-则$X \rightarrow \rightarrow YZ$，

​	-则$X \rightarrow \rightarrow Y \and Z$，

​	-则$X \rightarrow \rightarrow Y - Z, X \rightarrow \rightarrow Z-Y$

### 4NF

对于每个非平凡的多值依赖X都含有码

不存在非平凡的非函数依赖的多值依赖

## 模式分解的理论

### 模式分解定义

函数依赖集合$F_i = \{X \rightarrow Y \in F^+ \and XY \subseteq U_i\}$称Fi为F在Ui上的投影

R<U,F>的一个分解$\rho$是指

$\rho = \{ R_1<U_1, F_1>,...,R_n<U_n,F_n>\}$

### 分解的无损连接性

定义$m_\rho (r) = \Join \Pi_{Ri}(r)$,对于任何一个关系r都有$r=m_\rho(r)$则称为具有无损连接性和无损分解。

#### 无损分解的判定算法

n行k列表 见db_b_4

#### 无损分解的判定准则

无损连接性的充要条件是$U_1 \and U2 \rightarrow U_1-U_2 \in F^+$.

即R1，R2的共同属性至少构成二者之一的候选码

### 分解的保持函数依赖性

若$F^+ (U_{i=1}^n F_i)^+$则称这个分解保持函数依赖

#### 保持函数依赖性的判定方法

R中的每个函数依赖都能够从R1...Rn函数依赖的并集中逻辑导出

### 模式分解的原则

投影分解应该遵循无损链接行和保持函数依赖

### 模式分解的算法

#### 3NF保持函数依赖的分解算法

![](/Users/horatio/Desktop/DBSpic/截屏2021-10-25 上午8.44.43.png)

#### 3NF保持无损链接与函数依赖的分解算法

![](/Users/horatio/Desktop/DBSpic/截屏2021-10-25 上午9.01.36.png)

#### BCND无损连接分解的分解算法

![](/Users/horatio/Desktop/DBSpic/截屏2021-10-25 上午9.06.49.png)

## 候选码的求解理论和算法

### 属性分类

L：只在左部的属性

R：只在右部的属性

N：左右都没有出现

LR：均出现的属性

### 快速求解候选码的充分条件

![](/Users/horatio/Desktop/DBSpic/截屏2021-10-25 上午9.16.58.png)

N类必须自己决定自己，故一定是候选码。

### 左边为单属性的函数依赖集候选码成员的图论判定方法

F是R的**单属性**、**最小依赖集**，F为边，U为点构造有向图

![](/Users/horatio/Desktop/DBSpic/截屏2021-10-25 上午9.26.41.png)

![](/Users/horatio/Desktop/DBSpic/截屏2021-10-28 下午2.06.24.png)

![](/Users/horatio/Desktop/DBSpic/截屏2021-10-28 下午2.06.28.png)

![](/Users/horatio/Desktop/DBSpic/截屏2021-10-28 下午2.06.34.png)

### 多属性依赖集候选码求解法

![](/Users/horatio/Desktop/DBSpic/截屏2021-10-28 下午1.53.51.png)

L,N的闭包不是U，所以LR里面有。

# 数据库设计

## 数据库设计概述

### 数据库设计方法

#### 手工试凑法（直接涉及法）

![](/Users/horatio/Desktop/DBSpic/截屏2021-10-28 下午2.31.59.png)

#### 规范设计法

![](/Users/horatio/Desktop/DBSpic/截屏2021-10-28 下午2.32.36.png)

## 数据库设计的基本步骤

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-07 上午10.10.10.png)

## 需求分析

### 需求分析的目标

处理要求：指用户要完成什么处理功能，对处理的响应时间和处理方式的要求。

信息要求：指系统中所涉及的数据及数据之间的联系。具体手机数据的名类型、长度等，确定数据之间的联系的类型。

安全性与完整性的要求。

### 需求分析的方法

调查用户要求

分析表达用户需求

​	用数据流图表达 数据字典描述

#### 数据流图DFD

![](/Users/horatio/Desktop/DBSpic/截屏2021-10-28 下午3.07.32.png)

#### 数据字典

![](/Users/horatio/Desktop/DBSpic/截屏2021-10-28 下午3.07.36.png)

![](/Users/horatio/Desktop/DBSpic/截屏2021-10-28 下午3.07.40.png)

**需求分析阶段**的数据字典，可看成是数据元素表

在**数据库实施阶段**建立起的数据字典，是DBMS的重要组成部分。

## 概念结构设计(important)

### E-R图

![](/Users/horatio/Desktop/DBSpic/截屏2021-10-28 下午3.25.09.png)

![](/Users/horatio/Desktop/DBSpic/截屏2021-10-28 下午3.25.09.png)

![](/Users/horatio/Desktop/DBSpic/截屏2021-10-28 下午3.25.21.png)

### 设计概念结构的四类方法

![](/Users/horatio/Desktop/DBSpic/截屏2021-10-28 下午3.26.46.png)

#### 实体模型的调整原则

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-04 下午1.51.23.png)

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-04 下午1.51.28.png)

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-04 下午1.51.34.png)

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-04 下午1.51.48.png)

## 逻辑结构设计

## E-R图向关系模型的转换规则 

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-04 下午1.53.49.png)

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-04 下午1.54.06.png)

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-04 下午1.54.12.png)

### 关系模型的规范与优化

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-04 下午2.05.49.png)

#### 水平分解

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-04 下午2.06.08.png)

#### 垂直分解

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-04 下午2.07.11.png)

#### 设计用户子模式

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-04 下午2.06.29.png)

Create View已经限制了一遍条件，故查询条件的复杂度自然会降低。

## 物理结构设计

三级模式的内模式

### 确定数据库的存储结构

#### 确定存放位置

​	经常存取部分和存取频率较低部分分开存放

​	数据和日志备份放在不同的磁盘上

#### 确定系统配置

​	确定系统配置变量、存储分配参数、进行物理优化

### 常用存取方法

#### 索引方法

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-04 下午1.56.40.png)

##### 索引存取方法的选择

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-04 下午1.56.45.png)

#### 聚集方法

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-04 下午1.57.13.png)

#### HASH文件

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-04 下午1.58.00.png)

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-04 下午1.58.03.png)

# DBMS实现技术

## 概述

### DBMS查询执行过程

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-04 下午3.13.13.png)

### DBMS数据存储与查询实现基本框架

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-08 上午8.03.32.png)

## 存储管理和索引

​	DBMS设定数据库的基本存储是在磁盘上，DBMS的组建管理内存与外存数据的交换。

​	DBMS存储管理的目标：最小化磁盘和主存间传输存储块的数量，即最小化磁盘存取次数；实现手段是在主存中保持尽量多的块，使得上层要访问一个快时，他在主存中的概率最大

### 物理存储系统

#### 磁盘

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-08 上午8.12.36.png)

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-08 上午8.12.41.png)

页面和块一般是相同的

### 数据存储结构/物理结构

#### 存储管理系统

数据库由若干文件组成，文件由若干个定长的存储单存储块、页构成。

页事存储分配和数据传输的单位

DBMS的存储管理器负责维护文件，将文件组织为块、页的集合，且

​	-跟踪页的数据读取写入

​	-跟踪可用空间

#### 物理结构

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-08 上午8.24.24.png)

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-08 上午8.24.34.png)

每条记录在单个块中

#### 数据库页/磁盘块结构

页是固定大小的数据块

​	-可以包含元组/记录，原数据，索引，log记录等

​	-每个页有唯一标识符（ID），DBMS将页ID映射为页的物理位置

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-08 上午8.30.23.png)

##### 分槽页结构

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-08 上午8.31.35.png)

槽数组从下标0往下标大的方向增加，数据空间（记录）占用从后往前，所以才会连接在一起。

故槽数据的大小不固定。

##### 记录的结构

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-08 上午8.36.11.png)

并发控制考锁机制实现。

#### 文件的记录方式

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-08 上午8.42.29.png)

##### 堆文件组织

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-08 上午8.52.14.png)

##### 顺序文件组织

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-08 上午8.55.44.png)

主要是将主码用作搜索码

##### 聚集文件组织

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-08 上午8.58.32.png)

### 缓冲区管理

块、页是存储分配和数据交换的单位

管理目标：最小化磁盘和贮存见传输存储块的数量，即最小化磁盘存取次数，实现手段是在主存中保持尽量多的块。

缓冲区：是主存中可以存储磁盘块副本的区域

缓存管理器：负责缓存空间分配，内外存交换

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-08 上午9.08.38.png)

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-08 上午9.11.27.png)

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-08 上午9.15.42.png)

缓冲区中的共享锁和排它锁

## 索引

### 基本概念

索引记录/索引项，是索引文件的记录，包括两个域：

​	-索引域（搜索码，关键字）：存储数据文件中一个或一组域（属性）

​	-指针：指向索引域值为K的记录所在磁盘块的地址

索引将表中的部分属性进行组织或排序，使得利用这些属性能够快速有效的进行表的访问

DBMS负责在执行查询时使用最恰当的索引。

### 索引的分类

排序索引，哈希索引，聚集索引，非聚集索引，稠密索引，稀疏索引

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-08 上午9.29.05.png)

#### 稠密索引

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-08 上午9.30.33.png)

#### 稀疏索引

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-08 上午9.30.51.png)

#### 多级索引

​	外层索引 内层索引

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-08 上午9.31.42.png)

##### 二叉树索引

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-08 上午9.31.47.png)



![](/Users/horatio/Desktop/DBSpic/截屏2021-11-08 上午9.31.57.png)

##### B树（平衡树索引）

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-11 上午11.17.57.png)

#### B+树

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-11 上午11.18.24.png)

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-11 上午11.18.31.png)

##### B+树的查询

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-11 上午11.18.39.png)

##### B+树的更新（插入）

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-11 上午11.18.43.png)

##### B+树的更新（删除）

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-11 上午11.18.48.png)

##### B+树的文件组织

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-11 上午11.18.52.png)

#### HASH索引

基于哈希表（HASH Table）实现

哈希表实现key到value的映射，通过键值映射到表中一个位置来访问记录，这个映射函数叫做Hash函数，存放记录的数组叫做哈希表。

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-11 上午11.24.25.png)

##### Hash方法

哈希表的实现包括两部分

​	**哈希函数**：将很大的key空间映射到比较小的域，用于计算桶、槽数组的元素序号；非用于加密算法的哈希函数；计算速度快且碰撞率低。

​	**哈希方案（scheme）**：解决一个哈希值对应多条记录，最常使用溢出链接（Chaining）法

![](/Users/horatio/Desktop/DBSpic/截屏2021-11-11 上午11.51.08.png)

​	**静态哈希**：哈希表的大小是固定的

​		-文件增大时，太多的溢出桶将降低访问性能

​		-数据规模缩小时，会造成空间浪费

​	**动态哈希**：允许哈希表的大小动态修改

​		-定期重哈希：创建新的大的哈希表，把原表上的key重新哈西道新表上

​		-线性哈希：以一种递增的方式重新哈希

对于Hash索引而言

​	-周期性重组的开销大

​	-适用于检索哈希码具有特定值得记录检索，不适用于区间值的检索，以及部分匹配检索

​	-有很多重复值的列，不适于做key
